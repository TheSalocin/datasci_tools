<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>python_tools.networkx_utils &mdash; python_tools 1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            python_tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">python_tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">python_tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">python_tools.networkx_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for python_tools.networkx_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>




<span class="sd">Link on how to change parameters of nx.draw:</span>
<span class="sd">https://github.com/networkx/networkx/blob/main/networkx/drawing/nx_pylab.py#L584</span>





<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">networkx.classes.function</span> <span class="kn">import</span> <span class="n">path_weight</span> <span class="k">as</span> <span class="n">pw</span>
<span class="kn">from</span> <span class="nn">networkx.drawing.nx_pydot</span> <span class="kn">import</span> <span class="n">graphviz_layout</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">networkx.classes.function</span> <span class="k">as</span> <span class="nn">cls_func</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pydot</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>


<div class="viewcode-block" id="unpickle_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.unpickle_graph">[docs]</a><span class="k">def</span> <span class="nf">unpickle_graph</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">G_loaded</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">read_gpickle</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_loaded</span></div>

<div class="viewcode-block" id="pickle_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.pickle_graph">[docs]</a><span class="k">def</span> <span class="nf">pickle_graph</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">write_gpickle</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="find_reciprocal_connections"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.find_reciprocal_connections">[docs]</a><span class="k">def</span> <span class="nf">find_reciprocal_connections</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">redundant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will give a list of the edges that are reciprocal connections</span>
<span class="sd">    ** only gives one version of the reciprocal connections so doesn&#39;t repeat**</span>
<span class="sd">    </span>
<span class="sd">    Arguments: </span>
<span class="sd">    G: the graph to look for reciprocal connections</span>
<span class="sd">    redundant: whether to return a list with redundant connections or not (Ex: [(b,a)]  or [(b,a),(a,b)]</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from python_tools import networkx_utils as xu</span>
<span class="sd">    xu = reload(xu)</span>
<span class="sd">    xu.find_reciprocal_connections(returned_network)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reciprocal_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">redundant</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reciprocal_pairs</span>
    
    <span class="n">filtered_reciprocal_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">reciprocal_pairs</span><span class="p">:</span>       
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">filtered_reciprocal_pairs</span><span class="p">,[</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">filtered_reciprocal_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>

    <span class="n">filtered_reciprocal_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_reciprocal_pairs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_reciprocal_pairs</span></div>


<div class="viewcode-block" id="compare_endpoints"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.compare_endpoints">[docs]</a><span class="k">def</span> <span class="nf">compare_endpoints</span><span class="p">(</span><span class="n">endpoints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    comparing the endpoints of a graph: </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from python_tools import networkx_utils as xu</span>
<span class="sd">    xu = reload(xu)mess</span>
<span class="sd">    end_1 = np.array([[2,3,4],[1,4,5]])</span>
<span class="sd">    end_2 = np.array([[1,4,5],[2,3,4]])</span>

<span class="sd">    xu.compare_endpoints(end_1,end_2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#this older way mixed the elements of the coordinates together to just sort the columns</span>
    <span class="c1">#return np.array_equal(np.sort(endpoints_1,axis=0),np.sort(endpoints_2,axis=0))</span>
    
    <span class="c1">#this is correct way to do it (but has to be exact to return true)</span>
    <span class="c1">#return np.array_equal(nu.sort_multidim_array_by_rows(endpoints_1),nu.sort_multidim_array_by_rows(endpoints_2))</span>

    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="n">endpoints_1</span><span class="p">),</span>
                                <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="n">endpoints_2</span><span class="p">),</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="endpoint_connectivity"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.endpoint_connectivity">[docs]</a><span class="k">def</span> <span class="nf">endpoint_connectivity</span><span class="p">(</span><span class="n">endpoints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">,</span>
                         <span class="n">exceptions_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pupose: To determine where the endpoints of two branches are connected</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    end_1 = np.array([[759621., 936916., 872083.],</span>
<span class="sd">       [790891., 913598., 806043.]])</span>
<span class="sd">    end_2 = np.array([[790891., 913598., 806043.],</span>
<span class="sd">       [794967., 913603., 797825.]])</span>
<span class="sd">       </span>
<span class="sd">    endpoint_connectivity(end_1,end_2)</span>
<span class="sd">    &gt;&gt; {0: 1, 1: 0}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">connections_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">stacked_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">endpoints_1</span><span class="p">,</span><span class="n">endpoints_2</span><span class="p">])</span>
    <span class="n">endpoints_match</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">get_matching_vertices</span><span class="p">(</span><span class="n">stacked_endpoints</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">print_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No endpoints matching: </span><span class="si">{</span><span class="n">endpoints_match</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">exceptions_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connections_dict</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">print_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Multiple endpoints matching: </span><span class="si">{</span><span class="n">endpoints_match</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">exceptions_flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">print_string</span><span class="p">)</span>
    
    
    <span class="c1">#look at the first connection</span>
    <span class="n">first_match</span> <span class="o">=</span> <span class="n">endpoints_match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">first_endpoint_match</span> <span class="o">=</span> <span class="n">first_match</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_match = </span><span class="si">{</span><span class="n">first_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_endpoint_match = </span><span class="si">{</span><span class="n">endpoints_1</span><span class="p">[</span><span class="n">first_endpoint_match</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="n">first_endpoint_match</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">first_endpoint_match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non 0,1 matching node in first endpoint: </span><span class="si">{</span><span class="n">first_endpoint_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connections_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span><span class="n">first_endpoint_match</span><span class="p">})</span>
        
    <span class="n">second_endpoint_match</span> <span class="o">=</span> <span class="n">first_match</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="mi">2</span> <span class="o">!=</span> <span class="n">second_endpoint_match</span> <span class="ow">and</span> <span class="mi">3</span> <span class="o">!=</span> <span class="n">second_endpoint_match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non 2,3 matching node in second endpoint: </span><span class="si">{</span><span class="n">second_endpoint_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connections_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="n">second_endpoint_match</span><span class="o">-</span><span class="mi">2</span><span class="p">})</span>
    
    <span class="k">return</span> <span class="n">connections_dict</span></div>



<div class="viewcode-block" id="combine_graphs"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.combine_graphs">[docs]</a><span class="k">def</span> <span class="nf">combine_graphs</span><span class="p">(</span><span class="n">list_of_graphs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will combine graphs, but if they have the same name</span>
<span class="sd">    then will combine the nodes</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    xu = reload(xu)</span>
<span class="sd">    G1 = nx.from_edgelist([[1,2],[3,4],[2,3]])</span>
<span class="sd">    nx.draw(G1)</span>
<span class="sd">    plt.show()</span>

<span class="sd">    G2 = nx.from_edgelist([[3,4],[2,3],[2,5]])</span>
<span class="sd">    nx.draw(G2)</span>
<span class="sd">    plt.show()</span>

<span class="sd">    G3 = nx.compose_all([G1,G2])</span>
<span class="sd">    nx.draw(G3)</span>
<span class="sd">    plt.show()</span>

<span class="sd">    nx.draw(xu.combine_graphs([G1,G2,G3]))</span>
<span class="sd">    plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_graphs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">list_of_graphs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_graphs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;List of graphs is empty&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose_all</span><span class="p">(</span><span class="n">list_of_graphs</span><span class="p">)</span></div>

<div class="viewcode-block" id="edge_to_index"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_to_index">[docs]</a><span class="k">def</span> <span class="nf">edge_to_index</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">curr_edge</span><span class="p">):</span>
    <span class="n">matching_edges_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">(),</span><span class="n">curr_edge</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_edges_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">(),</span><span class="n">curr_edge</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">(),</span><span class="n">curr_edge</span><span class="p">)</span> </div>

<div class="viewcode-block" id="index_to_edge"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.index_to_edge">[docs]</a><span class="k">def</span> <span class="nf">index_to_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">edge_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">())[</span><span class="n">edge_idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="node_to_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.node_to_edges">[docs]</a><span class="k">def</span> <span class="nf">node_to_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_number</span><span class="p">):</span>
<span class="c1">#     if type(node_number) != list:</span>
<span class="c1">#         node_number = [node_number]</span>
    <span class="c1">#print(f&quot;node_number={node_number}&quot;)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">node_number</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">GraphOrderedEdges</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">(</span><span class="n">node_number</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;not expected type for G&quot;</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="get_node_list"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_list">[docs]</a><span class="k">def</span> <span class="nf">get_node_list</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">exclude_list</span> <span class="o">=</span> <span class="p">[]):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_list</span><span class="p">]</span></div>

<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="get_nodes_with_attributes_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_with_attributes_dict">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># --- 11/4 An aleration that instead calles the more efficient method ---</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;coordinates&quot;</span> <span class="ow">in</span> <span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">],</span><span class="n">return_single_value</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_search_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">total_search_keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_search_keys</span><span class="p">):</span>
            <span class="c1">#there were not enough keys in the node we were searching</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">search_key</span> <span class="ow">in</span> <span class="n">total_search_keys</span><span class="p">:</span>
                <span class="c1">#print(f&quot;y[search_key] = {y[search_key]}&quot;)</span>
                <span class="c1">#print(f&quot;attribute_dict[search_key] = {attribute_dict[search_key]}&quot;)</span>
                <span class="n">curr_search_val</span><span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">search_key</span><span class="p">]</span>
                <span class="c1">#if type(curr_search_val) in [type(np.array([])),type(np.ndarray([])),list,trimesh.caching.TrackedArray]:</span>
                <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">curr_search_val</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_search_val</span><span class="p">),</span><span class="n">attribute_dict</span><span class="p">[</span><span class="n">search_key</span><span class="p">]):</span>
                        <span class="n">add_flag</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">search_key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">search_key</span><span class="p">]:</span>
                        <span class="n">add_flag</span><span class="o">=</span><span class="kc">False</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">add_flag</span><span class="p">:</span>
                <span class="c1">#print(&quot;Added!&quot;)</span>
                <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node_list</span></div>

<div class="viewcode-block" id="get_nodes_with_attribute_value"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_with_attribute_value">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_with_attribute_value</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">nodesAt5</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span><span class="o">==</span><span class="n">value</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodesAt5</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes with </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">nodesAt5</span></div>

<div class="viewcode-block" id="get_graph_node_by_coordinate_old"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_graph_node_by_coordinate_old">[docs]</a><span class="k">def</span> <span class="nf">get_graph_node_by_coordinate_old</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">coordinate</span><span class="p">):</span>
    <span class="n">match_nodes</span> <span class="o">=</span> <span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">coordinate</span><span class="p">))</span>
    <span class="c1">#print(f&quot;match_nodes = {match_nodes}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not just one node in graph with coordinate </span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">match_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="get_coordinate_by_graph_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_coordinate_by_graph_node">[docs]</a><span class="k">def</span> <span class="nf">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will get the coordinates of node or list of nodes</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scalar_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">scalar_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">scalar_flag</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coords</span></div>
    
<div class="viewcode-block" id="get_graph_nodes_by_coordinates"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_graph_nodes_by_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_graph_nodes_by_coordinates</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">coordinates</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_graph_node_by_coordinate"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_graph_node_by_coordinate">[docs]</a><span class="k">def</span> <span class="nf">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">coordinate</span><span class="p">,</span><span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">return_neg_one_if_not_find</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Much faster way of searching for nodes by coordinates</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">node_coordinates</span> <span class="o">=</span> <span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span> <span class="o">=</span> <span class="n">graph_nodes</span><span class="p">)</span>
    <span class="n">match_nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">node_coordinates</span><span class="p">,</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_single_value</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_neg_one_if_not_find</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not just one node in graph with coordinate </span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">match_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">graph_nodes</span><span class="p">[</span><span class="n">match_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">graph_nodes</span><span class="p">[</span><span class="n">match_nodes</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_all_nodes_with_certain_attribute_key"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_all_nodes_with_certain_attribute_key">[docs]</a><span class="k">def</span> <span class="nf">get_all_nodes_with_certain_attribute_key</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span></div>

<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="get_node_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_attributes">[docs]</a><span class="k">def</span> <span class="nf">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">return_array</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1">#print(f&quot;attribute_name = {attribute_name}&quot;)</span>
    <span class="k">if</span> <span class="n">node_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">node_list</span><span class="p">):</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_list</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
    
    
    <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
    <span class="c1">#print(f&quot;attr_dict= {attr_dict}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;inside re-ordering&quot;)</span>
        <span class="c1">#attr_dict = dict([(k,v) for k,v in attr_dict.items() if k in node_list])</span>
        <span class="n">attr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">attr_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">attr_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">attr_dict</span></div>
    
<div class="viewcode-block" id="remove_selfloops"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_selfloops">[docs]</a><span class="k">def</span> <span class="nf">remove_selfloops</span><span class="p">(</span><span class="n">UG</span><span class="p">):</span>
    <span class="n">self_edges</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">selfloop_edges</span><span class="p">(</span><span class="n">UG</span><span class="p">)</span>
    <span class="c1">#print(f&quot;self_edges = {self_edges}&quot;)</span>
    <span class="n">UG</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">self_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">UG</span></div>

<div class="viewcode-block" id="get_neighbors"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_neighbors">[docs]</a><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">int_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">int_label</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span></div>
    
<div class="viewcode-block" id="get_neighbors_simple"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_neighbors_simple">[docs]</a><span class="k">def</span> <span class="nf">get_neighbors_simple</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">int_label</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span></div>
    
<div class="viewcode-block" id="neighbors"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.neighbors">[docs]</a><span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span> </div>
    
<div class="viewcode-block" id="get_nodes_of_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_of_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;degree&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_type</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_nodes_of_out_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_of_out_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_of_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;out_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">degree_choice</span><span class="p">]</span></div>
<div class="viewcode-block" id="get_nodes_of_in_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_of_in_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_of_in_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;in_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_nodes_greater_or_equal_out_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_greater_or_equal_out_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_greater_or_equal_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;out_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>
<div class="viewcode-block" id="get_nodes_greater_or_equal_in_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_greater_or_equal_in_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_greater_or_equal_in_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;in_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_nodes_less_or_equal_out_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_less_or_equal_out_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_less_or_equal_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;out_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>
<div class="viewcode-block" id="get_nodes_less_or_equal_in_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_less_or_equal_in_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_less_or_equal_in_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;in_degree&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="leaf_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.leaf_nodes">[docs]</a><span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span></div>
<div class="viewcode-block" id="non_leaf_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.non_leaf_nodes">[docs]</a><span class="k">def</span> <span class="nf">non_leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_greater_or_equal_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>
    
<span class="n">end_nodes</span> <span class="o">=</span> <span class="n">leaf_nodes</span>
<span class="c1"># def get_nodes_of_out_degree_k_Di(G,degree_choice):</span>
<span class="c1">#     return [n for n in G.nodes() if len(G[n]) == degree_choice]</span>

<div class="viewcode-block" id="get_nodes_greater_or_equal_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_greater_or_equal_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_greater_or_equal_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_nodes_less_or_equal_degree_k"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nodes_less_or_equal_degree_k">[docs]</a><span class="k">def</span> <span class="nf">get_nodes_less_or_equal_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_choice</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">degree_choice</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_node_degree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_degree">[docs]</a><span class="k">def</span> <span class="nf">get_node_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_name</span><span class="p">,</span>
                   <span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;in_and_out&quot;</span><span class="p">):</span>
    <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">node_name</span><span class="p">):</span>
        <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">node_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_name</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;in_and_out&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span>
    <span class="k">elif</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span>
    <span class="k">elif</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;out&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span>
        
    <span class="n">node_degrees</span> <span class="o">=</span> <span class="p">[</span><span class="n">degree_func</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">singular_flag</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_degrees</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="get_node_degree_out"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_degree_out">[docs]</a><span class="k">def</span> <span class="nf">get_node_degree_out</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_node_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_name</span><span class="p">,</span>
                   <span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_node_degree_in"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_degree_in">[docs]</a><span class="k">def</span> <span class="nf">get_node_degree_in</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_node_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_name</span><span class="p">,</span>
                   <span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;in&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="degree_distribution"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.degree_distribution">[docs]</a><span class="k">def</span> <span class="nf">degree_distribution</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;in_and_out&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;in_and_out&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span>
    <span class="k">elif</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span>
    <span class="k">elif</span> <span class="n">degree_type</span> <span class="o">==</span> <span class="s2">&quot;out&quot;</span><span class="p">:</span>
        <span class="n">degree_func</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span>
        
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">degree_func</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="max_node_degree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.max_node_degree">[docs]</a><span class="k">def</span> <span class="nf">max_node_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;in_and_out&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">degree_distribution</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="n">degree_type</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="get_coordinate_degree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_coordinate_degree">[docs]</a><span class="k">def</span> <span class="nf">get_coordinate_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">coordinate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the degrees of coordinates</span>
<span class="sd">    inside of a graph</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">endpoint_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate</span><span class="p">]</span>
    <span class="n">endpoint_degrees</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">endpoint_nodes</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">endpoint_degrees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">endpoint_degrees</span></div>
    


<div class="viewcode-block" id="set_node_attributes_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_node_attributes_dict">[docs]</a><span class="k">def</span> <span class="nf">set_node_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Can set the attributes of nodes with dictionaries </span>
<span class="sd">    </span>
<span class="sd">    ex: </span>
<span class="sd">    G = nx.path_graph(3)</span>
<span class="sd">    attrs = {0: {&#39;attr1&#39;: 20, &#39;attr2&#39;: &#39;nothing&#39;}, 1: {&#39;attr2&#39;: 3}}</span>
<span class="sd">    nx.set_node_attributes(G, attrs)</span>
<span class="sd">    G.nodes[0][&#39;attr1&#39;]</span>

<span class="sd">    G.nodes[0][&#39;attr2&#39;]</span>

<span class="sd">    G.nodes[1][&#39;attr2&#39;]</span>

<span class="sd">    G.nodes[2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="relabel_node_names"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.relabel_node_names">[docs]</a><span class="k">def</span> <span class="nf">relabel_node_names</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">mapping</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished relabeling nodes&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
    
<span class="n">rename_nodes</span> <span class="o">=</span> <span class="n">relabel_node_names</span>
    
<div class="viewcode-block" id="get_all_attributes_for_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_all_attributes_for_nodes">[docs]</a><span class="k">def</span> <span class="nf">get_all_attributes_for_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[],</span>
                       <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">node_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    <span class="n">attributes_list</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">attributes_list_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
        <span class="n">attributes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">attributes_list_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">n</span><span class="p">:</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]})</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes_list_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes_list</span></div>
    
<div class="viewcode-block" id="get_node_attribute_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_attribute_dict">[docs]</a><span class="k">def</span> <span class="nf">get_node_attribute_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">])</span></div>
    
<span class="c1"># -------------- start of functions to help with edges ---------------#</span>
<div class="viewcode-block" id="get_all_attributes_for_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_all_attributes_for_edges">[docs]</a><span class="k">def</span> <span class="nf">get_all_attributes_for_edges</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">edges_list</span><span class="o">=</span><span class="p">[],</span><span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    G1 = limb_concept_network</span>
<span class="sd">    xu.get_all_attributes_for_edges(G1,return_dict=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edge list was 0 so generating sorted edges&quot;</span><span class="p">)</span>
        <span class="n">edges_list</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span><span class="n">order_row_items</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">G1</span><span class="p">,(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;**Warning the length of edges_list (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">)</span><span class="si">}</span><span class="s2">) is less than the total number of edges for Graph**&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">attributes_list</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="n">attributes_list_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges_list</span><span class="p">:</span>
        <span class="n">attributes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G1</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span>
        <span class="n">attributes_list_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span><span class="n">G1</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]})</span>
    
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes_list_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes_list</span></div>


<div class="viewcode-block" id="get_edges_with_attributes_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edges_with_attributes_dict">[docs]</a><span class="k">def</span> <span class="nf">get_edges_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Did not recieve dictionary for searching&quot;</span><span class="p">)</span>
    <span class="n">total_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_searching_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">total_searching_keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]))))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_searching_keys</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_searching_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span>  <span class="n">attribute_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">total_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">total_edges</span></div>
               


<div class="viewcode-block" id="get_edge_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edge_attributes">[docs]</a><span class="k">def</span> <span class="nf">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">edge_list</span><span class="o">=</span><span class="p">[],</span><span class="n">undirected</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1">#print(f&quot;edge_list = {edge_list}, type={type(edge_list)}, shape = {edge_list.shape}&quot;)</span>
    <span class="c1">#print(&quot;&quot;)</span>
    <span class="n">edge_attributes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="s2">&quot;order&quot;</span><span class="p">)</span>
    <span class="c1">#print(f&quot;edge_attributes = {edge_attributes}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">undirected</span><span class="p">:</span>
            <span class="n">total_attributes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">total_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_attributes</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="c1">#try the other way around to see if it exists</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">total_attributes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_attributes</span><span class="p">[</span><span class="nb">tuple</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>
                    <span class="k">except</span><span class="p">:</span> 
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_attributes = </span><span class="si">{</span><span class="n">edge_attributes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(e[-1],e[0]) = </span><span class="si">{</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error in get_edge_attributes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">total_attributes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">edge_attributes</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_attributes</span></div>

<div class="viewcode-block" id="get_edge_attributes_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edge_attributes_df">[docs]</a><span class="k">def</span> <span class="nf">get_edge_attributes_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attributes</span><span class="p">,</span> <span class="c1">#= &quot;presyn_soma_postsyn_soma_euclid_dist&quot;</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_array</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To retrieve a dataframe of the</span>
<span class="sd">    edge attributes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">attributes</span><span class="p">):</span>
        <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
    <span class="n">attribute_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">singular_flag</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span>

    <span class="k">if</span> <span class="n">return_df</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">attribute_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attribute_dict</span></div>

<span class="c1">#import copy</span>
<span class="c1"># how you can try to remove a cycle from a graph</span>
<div class="viewcode-block" id="remove_cycle"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_cycle">[docs]</a><span class="k">def</span> <span class="nf">remove_cycle</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">,</span> <span class="n">max_cycle_iterations</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span> 
    
    <span class="c1">#branch_subgraph_copy = copy.copy(branch_subgraph)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_cycle_iterations</span><span class="p">):</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">edges_in_cycle</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#make a copy to unfreeze</span>
            <span class="n">branch_subgraph</span> <span class="o">=</span> <span class="n">GraphOrderedEdges</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
            <span class="c1">#not doing random deletion just picking first edge</span>
            <span class="n">picked_edge_to_delete</span> <span class="o">=</span> <span class="n">edges_in_cycle</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#print(f&quot;picked_edge_to_delete = {picked_edge_to_delete}&quot;)</span>
            <span class="n">branch_subgraph</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">picked_edge_to_delete</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">picked_edge_to_delete</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            

    <span class="k">try</span><span class="p">:</span>
        <span class="n">edges_in_cycle</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">find_cycle</span><span class="p">(</span><span class="n">branch_subgraph</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was still a cycle left after cleanup&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">branch_subgraph</span></div>


<div class="viewcode-block" id="find_skeletal_distance_along_graph_node_path"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.find_skeletal_distance_along_graph_node_path">[docs]</a><span class="k">def</span> <span class="nf">find_skeletal_distance_along_graph_node_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the skeletal distance along nodes of</span>
<span class="sd">    a graph that represents a skeleton</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the coordinates of the nodes</span>
<span class="sd">    2) Find the distances between consecutive coordinates</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    find_skeletal_distance_along_graph_node_path(</span>
<span class="sd">                                                G = skeleton_graph,</span>
<span class="sd">                                                node_path = cycles_list[0]</span>
<span class="sd">                                                )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">node_path</span><span class="p">)</span>
    <span class="n">total_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">total_distance</span></div>


<div class="viewcode-block" id="find_all_cycles"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.find_all_cycles">[docs]</a><span class="k">def</span> <span class="nf">find_all_cycles</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cycle_length_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">time_limit</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">time_limit</span><span class="p">(</span><span class="n">time_limit</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;forked from networkx dfs_edges function. Assumes nodes are integers, or at least</span>
<span class="sd">            types which work with min() and &gt; .&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># produce edges for all components</span>
                <span class="n">comp_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))]</span>
                <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comp_list</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># produce edges for components with source</span>
                <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="c1"># extra variables for cycle detection:</span>
            <span class="n">cycle_stack</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">output_cycles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">get_hashable_cycle</span><span class="p">(</span><span class="n">cycle</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;cycle as a tuple in a deterministic order.&quot;&quot;&quot;</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
                <span class="n">mi</span> <span class="o">=</span> <span class="n">cycle</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">mi_plus_1</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">mi</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">cycle</span><span class="p">[</span><span class="n">mi</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cycle</span><span class="p">[</span><span class="n">mi_plus_1</span><span class="p">]:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">mi</span><span class="p">:]</span> <span class="o">+</span> <span class="n">cycle</span><span class="p">[:</span><span class="n">mi</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">cycle</span><span class="p">[:</span><span class="n">mi_plus_1</span><span class="p">]))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="n">mi_plus_1</span><span class="p">:]))</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="c1">#print(f&quot;start = {start}&quot;)</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">cycle_stack</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">cycle_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

                <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">start</span><span class="p">]))]</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="c1">#print(f&quot;len(stack) = {len(stack)}&quot;)</span>
                    <span class="n">parent</span><span class="p">,</span><span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cycle_stack</span><span class="p">:</span>
                            <span class="n">cycle_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span><span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">])))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="n">cycle_stack</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle_stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span> 
                                <span class="n">output_cycles</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">get_hashable_cycle</span><span class="p">(</span><span class="n">cycle_stack</span><span class="p">[</span><span class="n">i</span><span class="p">:]))</span>

                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">cycle_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">su</span><span class="o">.</span><span class="n">TimeoutException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Timed out when trying to find the cycles!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
        
    
    <span class="n">cycles_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output_cycles</span><span class="p">]</span>
    <span class="n">cycles_list_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cycles_list</span><span class="p">)</span>
    <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cycles_list_array</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cycles_list_sorted</span> <span class="o">=</span> <span class="n">cycles_list_array</span><span class="p">[</span><span class="n">sorted_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">cycles_list_sorted</span><span class="p">)</span> </div>


<div class="viewcode-block" id="set_node_data"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_node_data">[docs]</a><span class="k">def</span> <span class="nf">set_node_data</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">node_name</span><span class="p">,</span><span class="n">curr_data</span><span class="p">,</span><span class="n">curr_data_label</span><span class="p">):</span>
    
        <span class="n">node_attributes_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2"> not in the concept map of the curent neuron before trying to add </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2"> to the concept graph&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_attributes_dict</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_data_label</span><span class="p">:</span><span class="n">curr_data</span><span class="p">}</span>
                
        <span class="c1">#setting the actual attributes</span>
        <span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">node_attributes_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="GraphOrderedEdges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges">[docs]</a><span class="k">class</span> <span class="nc">GraphOrderedEdges</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example of how to use:</span>
<span class="sd">    - graph that has ordered edges</span>
<span class="sd">    </span>
<span class="sd">    xu = reload(xu)</span>

<span class="sd">    ordered_Graph = xu.GraphEdgeOrder()</span>
<span class="sd">    ordered_Graph.add_edge(1,2)</span>
<span class="sd">    ordered_Graph.add_edge(4,3)</span>
<span class="sd">    ordered_Graph.add_edge(1,3)</span>
<span class="sd">    ordered_Graph.add_edge(3,4)</span>

<span class="sd">    ordered_Graph.add_edges_from([(5,6),(2,3),(3,8)])</span>
<span class="sd">    xu.get_edge_attributes(ordered_Graph)</span>

<span class="sd">    xu.get_edge_attributes(ordered_Graph,&quot;order&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GraphOrderedEdges.__init__"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">edge_order</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="c1">#set the edge order</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">edge_order</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())]))</span></div>
            
        
    
    <span class="c1">#make sure don&#39;t lose properties when turning to undirected</span>
<span class="c1">#     def to_undirected(self):</span>
<span class="c1">#         edge_order = get_edge_attributes(self)</span>
<span class="c1">#         #super().to_undirected()</span>
<span class="c1">#         #self.__init__(self,edge_order=edge_order)</span>
        
    
    <span class="c1">#just want to add some functions that ordered edges </span>
<div class="viewcode-block" id="GraphOrderedEdges.add_edge"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will add the edge plus an order index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="c1">#print(f&quot;Total edges already = {total_edges}&quot;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="n">total_edges</span><span class="p">)</span></div>
    
    <span class="c1">#will do the adding edges</span>
<div class="viewcode-block" id="GraphOrderedEdges.add_edges_from"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.add_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ebunch_to_add</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="c1">#get the total edges</span>
        <span class="n">total_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="c1">#get the new labels</span>
        
        <span class="n">ebunch_to_add</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ebunch_to_add</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebunch_to_add</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#add the edges</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">ebunch_to_add</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
            <span class="c1">#changes the ebunch if has dictionary associated with it</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebunch_to_add</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ebunch_to_add</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">ebunch_to_add</span><span class="p">]</span>
                
            <span class="n">ending_edge_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
            
            <span class="n">new_orders</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_edges</span><span class="p">,</span><span class="n">total_edges</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ebunch_to_add</span><span class="p">)))</span>
            
<span class="c1">#             print(f&quot;total_edges = {total_edges}&quot;)</span>
<span class="c1">#             print(f&quot;len(new_orders) = {len(new_orders)}&quot;)</span>
<span class="c1">#             print(f&quot;len(ebunch_to_add) = {len(ebunch_to_add)}&quot;)</span>
<span class="c1">#             print(f&quot;ending_edge_count = {ending_edge_count}&quot;)</span>
            
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_orders</span><span class="p">,</span><span class="n">ebunch_to_add</span><span class="p">)]))</span></div>
        
<div class="viewcode-block" id="GraphOrderedEdges.add_weighted_edges_from"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.add_weighted_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">add_weighted_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ebunch_to_add</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="n">weight</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ebunch_to_add</span><span class="p">),</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="c1">#will get the edges in an ordered format</span>
<div class="viewcode-block" id="GraphOrderedEdges.edges_ordered"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.edges_ordered">[docs]</a>    <span class="k">def</span> <span class="nf">edges_ordered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        nbunch: </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">returned_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">returned_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">)))</span>
        <span class="c1">#print(f&quot;returned_edges = {returned_edges}&quot;)</span>
        <span class="c1">#get the order of all of these edges</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">returned_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">edge_list</span><span class="o">=</span><span class="n">returned_edges</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">edge_list</span><span class="o">=</span><span class="n">returned_edges</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">returned_edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">orders</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">returned_edges</span></div>
        
<div class="viewcode-block" id="GraphOrderedEdges.reorder_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.reorder_edges">[docs]</a>    <span class="k">def</span> <span class="nf">reorder_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="n">ord_ed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ord_ed</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ord_ed</span><span class="p">)]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c1">#do nothing because no edges to reorder</span></div>
        
    <span class="c1">#functions that will do the deleting of edges and then reordering</span>
<div class="viewcode-block" id="GraphOrderedEdges.remove_edge"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.remove_edge">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="c1">#print(&quot;in remove edge&quot;)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span></div>
    
    
    <span class="c1">#the add_weighted_edges_from will already use the add_edges_from</span>
<div class="viewcode-block" id="GraphOrderedEdges.remove_edges_from"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.remove_edges_from">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ebunch</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span></div>
    
    <span class="c1">#*************** overload delete vertex************</span>
<div class="viewcode-block" id="GraphOrderedEdges.remove_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.remove_node">[docs]</a>    <span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="GraphOrderedEdges.remove_nodes_from"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.GraphOrderedEdges.remove_nodes_from">[docs]</a>    <span class="k">def</span> <span class="nf">remove_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorder_edges</span><span class="p">()</span></div></div>
        
<span class="c1"># ------------------ for neuron package -------------- #</span>
<div class="viewcode-block" id="get_starting_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_starting_node">[docs]</a><span class="k">def</span> <span class="nf">get_starting_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_for_start</span><span class="o">=</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">starting_node_dict</span> <span class="o">=</span> <span class="n">get_all_nodes_with_certain_attribute_key</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_for_start</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">only_one</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">starting_node_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of starting nodes was not equal to 1: starting_node_dict = </span><span class="si">{</span><span class="n">starting_node_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">starting_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">starting_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">starting_node</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">starting_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="compare_networks"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.compare_networks">[docs]</a><span class="k">def</span> <span class="nf">compare_networks</span><span class="p">(</span>
    <span class="n">G1</span><span class="p">,</span>
    <span class="n">G2</span><span class="p">,</span>
    <span class="n">compare_edge_attributes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span>
    <span class="n">compare_edge_attributes_exclude</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">edge_threshold_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">],</span>
    <span class="n">edge_comparison_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">compare_node_attributes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span> 
    <span class="n">compare_node_attributes_exclude</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">node_threshold_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">,</span><span class="s2">&quot;endpoints&quot;</span><span class="p">],</span>
    <span class="n">node_comparison_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">return_differences</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To customly compare graphs based on the edges attributes and nodes you want to compare</span>
<span class="sd">    AND TO MAKE SURE THEY HAVE THE SAME NODE NAMES</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    G1,G2,#the 2 graphs that will be compared</span>
<span class="sd">    compare_edge_attributes=[],#whether to consider the edge attributes when comparing</span>
<span class="sd">    edge_threshold_attributes = [], #the names of attributes that will be considered close if below edge_comparison_threshold</span>
<span class="sd">    edge_comparison_threshold=0, #the threshold for comparing the attributes named in edge_threshold_attributes</span>
<span class="sd">    compare_node_attributes=[], #whether to consider the node attributes when comparing</span>
<span class="sd">    node_threshold_attributes = [], #the names of attributes that will be considered close if below node_comparison_threshold</span>
<span class="sd">    node_comparison_threshold=0, #the threshold for comparing the attributes named in node_threshold_attributes</span>
<span class="sd">    print_flag=False</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    0) check that number of edges and nodes are the same, if not then return false</span>
<span class="sd">    1) compare the sorted edges array to see if equal</span>
<span class="sd">    2) compare the edge weights are the same (maybe within a threshold) (BUT MUST SPECIFY THRESHOLD)</span>
<span class="sd">    3) For each node name: </span>
<span class="sd">    - check that the attributes are the same</span>
<span class="sd">    - can specify attribute names that can be within a certian threshold (BUT MUST SPECIFY THRESHOLD)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    # Testing of the graph comparison </span>
<span class="sd">    network_copy = limb_concept_network.copy()</span>
<span class="sd">    network_copy_2 = network_copy.copy()</span>

<span class="sd">    #changing and seeing if we can pick up on the difference</span>
<span class="sd">    network_copy[1][2][&quot;order&quot;] = 55</span>
<span class="sd">    network_copy_2.nodes[2][&quot;endpoints&quot;] = np.array([[1,2,3],[4,5,6]])</span>
<span class="sd">    network_copy_2.nodes[3][&quot;endpoints&quot;] = np.array([[1,2,5],[4,5,6]])</span>
<span class="sd">    network_copy_2.remove_edge(1,2)</span>

<span class="sd">    xu.compare_networks(</span>
<span class="sd">        G1=network_copy,</span>
<span class="sd">        G2=network_copy_2,</span>
<span class="sd">        compare_edge_attributes=[&quot;all&quot;],</span>
<span class="sd">        edge_threshold_attributes = [],</span>
<span class="sd">        edge_comparison_threshold=0,</span>
<span class="sd">        compare_node_attributes=[&quot;endpoints&quot;], </span>
<span class="sd">        node_threshold_attributes = [&quot;endpoints&quot;],</span>
<span class="sd">        node_comparison_threshold=0.1,</span>
<span class="sd">        print_flag=True</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">    Example with directional: </span>
<span class="sd">    #directional test </span>

<span class="sd">    network_copy = limb_concept_network.copy()</span>
<span class="sd">    network_copy_2 = network_copy.copy()</span>

<span class="sd">    #changing and seeing if we can pick up on the difference</span>

<span class="sd">    network_copy_2.nodes[2][&quot;endpoints&quot;] = np.array([[1,2,3],[4,5,6]])</span>
<span class="sd">    network_copy_2.nodes[3][&quot;endpoints&quot;] = np.array([[1,2,5],[4,5,6]])</span>
<span class="sd">    del network_copy_2.nodes[12][&quot;starting_coordinate&quot;]</span>
<span class="sd">    #network_copy_2.remove_edge(1,2)</span>

<span class="sd">    xu.compare_networks(</span>
<span class="sd">        G1=network_copy,</span>
<span class="sd">        G2=network_copy_2,</span>
<span class="sd">        compare_edge_attributes=[&quot;all&quot;],</span>
<span class="sd">        edge_threshold_attributes = [],</span>
<span class="sd">        edge_comparison_threshold=0,</span>
<span class="sd">        compare_node_attributes=[&quot;all&quot;], </span>
<span class="sd">        node_threshold_attributes = [&quot;endpoints&quot;],</span>
<span class="sd">        compare_node_attributes_exclude=[&quot;data&quot;],</span>
<span class="sd">        node_comparison_threshold=0.1,</span>
<span class="sd">        print_flag=True</span>
<span class="sd">        )</span>
<span class="sd">    </span>
<span class="sd">    Example on how to use to compare skeletons: </span>
<span class="sd">    skeleton_1 = copy.copy(total_skeleton)</span>
<span class="sd">    skeleton_2 = copy.copy(total_skeleton)</span>
<span class="sd">    skeleton_1[0][0] = np.array([558916.8, 1122107. ,  842972.8])</span>

<span class="sd">    sk_1_graph = sk.convert_skeleton_to_graph(skeleton_1)</span>
<span class="sd">    sk_2_graph = sk.convert_skeleton_to_graph(skeleton_2)</span>

<span class="sd">    xu.compare_networks(sk_1_graph,sk_2_graph,print_flag=True,</span>
<span class="sd">                     edge_comparison_threshold=2,</span>
<span class="sd">                     node_comparison_threshold=2)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">total_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">local_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">compare_edge_attributes</span><span class="p">):</span>
        <span class="n">compare_edge_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">compare_edge_attributes</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">compare_edge_attributes</span><span class="p">):</span>
        <span class="n">compare_edge_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">compare_edge_attributes</span><span class="p">]</span>
      
    <span class="n">differences_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#0) check that number of edges and nodes are the same, if not then return false</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G1</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G1</span><span class="p">)):</span>
            <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type of G1 graph (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match type of G2 graph(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
            <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of edges in G1 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">) does not match number of edges in G2 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
            <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of nodes in G1 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">) does not match number of nodes in G2 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
            <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes in G1 (</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="si">}</span><span class="s2">) does not match nodes in G2 (</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for intial checks: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_compare_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#1) compare the sorted edges array to see if equal</span>
        <span class="n">unordered_bool</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()))</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">GraphOrderedEdges</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unordered_bool = </span><span class="si">{</span><span class="n">unordered_bool</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#already checked for matching edge length so now guard against the possibility that no edges:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>


            <span class="n">G1_sorted_edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">()),</span><span class="n">order_row_items</span><span class="o">=</span><span class="n">unordered_bool</span><span class="p">)</span>
            <span class="n">G2_sorted_edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">sort_multidim_array_by_rows</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">()),</span><span class="n">order_row_items</span><span class="o">=</span><span class="n">unordered_bool</span><span class="p">)</span>


            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">G1_sorted_edges</span><span class="p">,</span><span class="n">G2_sorted_edges</span><span class="p">):</span>
                <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;The edges array are not equal &quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Sorting and Comparing Edges: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_compare_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1">#2) compare the edge weights are the same (maybe within a threshold) (BUT MUST SPECIFY THRESHOLD)</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compare_edge_attributes = </span><span class="si">{</span><span class="n">compare_edge_attributes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compare_edge_attributes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

                <span class="n">G1_edge_attributes</span> <span class="o">=</span> <span class="n">get_all_attributes_for_edges</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">edges_list</span><span class="o">=</span><span class="n">G1_sorted_edges</span><span class="p">,</span><span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">G2_edge_attributes</span> <span class="o">=</span> <span class="n">get_all_attributes_for_edges</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">edges_list</span><span class="o">=</span><span class="n">G2_sorted_edges</span><span class="p">,</span><span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                loop that will go through each edge and compare the dictionaries:</span>
<span class="sd">                - only compare the attributes selected (compare all if &quot;all&quot; in list)</span>
<span class="sd">                - if certain attributes show up in the edge_threshold_attributes then compare then against the edge_comparison_threshold</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">curr_edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G1_edge_attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">G1_edge_dict</span> <span class="o">=</span> <span class="n">G1_edge_attributes</span><span class="p">[</span><span class="n">curr_edge</span><span class="p">]</span>
                    <span class="n">G2_edge_dict</span> <span class="o">=</span> <span class="n">G2_edge_attributes</span><span class="p">[</span><span class="n">curr_edge</span><span class="p">]</span>
                    <span class="c1">#print(f&quot;G1_edge_dict.keys() = {G1_edge_dict.keys()}&quot;)</span>

                    <span class="k">if</span> <span class="s2">&quot;all&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_edge_attributes</span><span class="p">:</span>
                        <span class="n">G1_edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G1_edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compare_edge_attributes</span><span class="p">])</span>
                        <span class="n">G2_edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G2_edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compare_edge_attributes</span><span class="p">])</span>

                    <span class="c1">#do the exclusion of some attributes:</span>
                    <span class="n">G1_edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G1_edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_edge_attributes_exclude</span><span class="p">])</span>
                    <span class="n">G2_edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G2_edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_edge_attributes_exclude</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">z</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example G1_edge_dict = </span><span class="si">{</span><span class="n">G1_edge_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                    <span class="c1">#check that they have the same number of keys</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G2_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The dictionaries for the edge </span><span class="si">{</span><span class="n">curr_edge</span><span class="si">}</span><span class="s2"> did not have same keys in G1 (</span><span class="si">{</span><span class="n">G1_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">) as G2 (</span><span class="si">{</span><span class="n">G2_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                        <span class="c1">#return False</span>
                    <span class="c1">#print(f&quot;G1_edge_dict.keys() = {G1_edge_dict.keys()}&quot;)</span>
                    <span class="c1">#check that all of the values for each key match</span>
                    <span class="k">for</span> <span class="n">curr_key</span> <span class="ow">in</span> <span class="n">G1_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1">#print(f&quot;{(G1_edge_dict[curr_key],G2_edge_dict[curr_key])}&quot;)</span>
                        <span class="k">if</span> <span class="n">curr_key</span> <span class="ow">in</span> <span class="n">edge_threshold_attributes</span><span class="p">:</span>
                            <span class="n">value_difference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="o">-</span><span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">value_difference</span> <span class="o">&gt;</span> <span class="n">edge_comparison_threshold</span><span class="p">:</span>
                                <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The edge </span><span class="si">{</span><span class="n">curr_edge</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;that was above the current edge_comparison_threshold (</span><span class="si">{</span><span class="n">edge_comparison_threshold</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                                <span class="c1">#return False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">],</span><span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]):</span>
                                    <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The edge </span><span class="si">{</span><span class="n">curr_edge</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]:</span>
                                    <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The edge </span><span class="si">{</span><span class="n">curr_edge</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_edge_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                                    <span class="c1">#return False</span>

        <span class="c1">#if no discrepancy has been detected then return True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Made it through edge comparison without there being any discrepancies&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Checking Edges Attributes : </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_compare_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        3) For each node name: </span>
<span class="sd">        - check that the attributes are the same</span>
<span class="sd">        - can specify attribute names that can be within a certian threshold (BUT MUST SPECIFY THRESHOLD)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compare_node_attributes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

            <span class="n">G1_node_attributes</span> <span class="o">=</span> <span class="n">get_all_attributes_for_nodes</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">G2_node_attributes</span> <span class="o">=</span> <span class="n">get_all_attributes_for_nodes</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span><span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            loop that will go through each node and compare the dictionaries:</span>
<span class="sd">            - only compare the attributes selected (compare all if &quot;all&quot; in list)</span>
<span class="sd">            - if certain attributes show up in the node_threshold_attributes then compare then against the node_comparison_threshold</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compare_node_attributes = </span><span class="si">{</span><span class="n">compare_node_attributes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G1_node_attributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">G1_node_dict</span> <span class="o">=</span> <span class="n">G1_node_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">G2_node_dict</span> <span class="o">=</span> <span class="n">G2_node_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

                <span class="k">if</span> <span class="s2">&quot;all&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_node_attributes</span><span class="p">:</span>
                    <span class="n">G1_node_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G1_node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compare_node_attributes</span><span class="p">])</span>
                    <span class="n">G2_node_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G2_node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compare_node_attributes</span><span class="p">])</span>


                <span class="c1">#doing the exlusion</span>
                <span class="n">G1_node_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G1_node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_node_attributes_exclude</span><span class="p">])</span>
                <span class="n">G2_node_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G2_node_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">compare_node_attributes_exclude</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">z</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Example G1_edge_dict = </span><span class="si">{</span><span class="n">G1_node_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="c1">#check that they have the same number of keys</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G1_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G2_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                    <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The dictionaries for the node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> did not have same keys in G1 (</span><span class="si">{</span><span class="n">G1_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">) as G2 (</span><span class="si">{</span><span class="n">G2_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                    <span class="c1">#return False</span>

                <span class="c1">#check that all of the values for each key match</span>
                <span class="k">for</span> <span class="n">curr_key</span> <span class="ow">in</span> <span class="n">G1_node_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1">#print(f&quot;curr_key = {curr_key}&quot;)</span>

                    <span class="k">if</span> <span class="n">curr_key</span> <span class="ow">in</span> <span class="n">node_threshold_attributes</span><span class="p">:</span>
                        <span class="n">value_difference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="o">-</span><span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">value_difference</span> <span class="o">&gt;</span> <span class="n">node_comparison_threshold</span><span class="p">:</span>
                            <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;that was above the current node_comparison_threshold (</span><span class="si">{</span><span class="n">node_comparison_threshold</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                            <span class="c1">#return False</span>
                    <span class="k">else</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]):</span>
                            <span class="c1">#print((set(list(G1_node_dict.keys())),set(list(G2_node_dict.keys()))))</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">],</span><span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]):</span>
                                <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                                <span class="c1">#return False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#print(f&quot;curr_key = {curr_key}&quot;)</span>
                            <span class="c1">#print(f&quot;G1_node_dict[curr_key] != G2_node_dict[curr_key] = {G1_node_dict[curr_key] != G2_node_dict[curr_key]}&quot;)</span>
                            <span class="c1">#print(f&quot;G1_node_dict[curr_key] = {G1_node_dict[curr_key]}, G2_node_dict[curr_key] = {G2_node_dict[curr_key]}&quot;)</span>
                            <span class="k">if</span> <span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]:</span>
                                <span class="n">differences_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has a different value for </span><span class="si">{</span><span class="n">curr_key</span><span class="si">}</span><span class="s2"> in G1 (</span><span class="si">{</span><span class="n">G1_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) and in G2 (</span><span class="si">{</span><span class="n">G2_node_dict</span><span class="p">[</span><span class="n">curr_key</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                                <span class="c1">#return False</span>
                        <span class="c1">#print(f&quot;differences_list = {differences_list}&quot;)</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Comparing Node Attributes: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_compare_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_compare_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1">#if no discrepancy has been detected then return True</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Made it through Node comparison without there being any discrepancies&quot;</span><span class="p">)</span>
        <span class="n">return_boolean</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Differences List:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">differences_list</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)   </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">return_boolean</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">if</span> <span class="n">return_differences</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;return_differences is None!!!&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_differences</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_boolean</span><span class="p">,</span><span class="n">differences_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_boolean</span></div>
    
<span class="c1"># -------------- 8/4 additions ----------------------- #</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">How to determine upstream and downstream targets</span>

<span class="sd">Example: </span>
<span class="sd">#import networkx as nx</span>
<span class="sd">#import matplotlib.pyplot as plt</span>
<span class="sd">G = nx.DiGraph()</span>
<span class="sd">G.add_edges_from(</span>
<span class="sd">    [(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;B&#39;), (&#39;E&#39;, &#39;C&#39;), (&#39;E&#39;, &#39;F&#39;),(&#39;F&#39;,&#39;Z&#39;),</span>
<span class="sd">     (&#39;B&#39;, &#39;H&#39;), (&#39;B&#39;, &#39;G&#39;), (&#39;B&#39;, &#39;F&#39;), (&#39;C&#39;, &#39;G&#39;), (&#39;Q&#39;, &#39;D&#39;)])</span>

<span class="sd">pos = nx.spring_layout(G)</span>
<span class="sd">nx.draw_networkx_nodes(G, pos, cmap=plt.get_cmap(&#39;jet&#39;),node_size = 50)</span>
<span class="sd">nx.draw_networkx_edges(G, pos, edge_color=&#39;r&#39;, arrows=True)</span>
<span class="sd">nx.draw_networkx_labels(G, pos)</span>
<span class="sd">plt.show()</span>

<span class="sd">print(&quot;Downstream Edges of &#39;B&#39; (just example)--&gt;&quot;)</span>
<span class="sd">print(list(nx.dfs_edges(G,&#39;B&#39;)))</span>
<span class="sd">print(downstream_edges(G,&quot;B&quot;))</span>
<span class="sd">print(downstream_edges_neighbors(G,&quot;B&quot;))</span>


<span class="sd">print(&quot;\nUpstream Edges of &#39;B&#39; (just example)--&gt;&quot;)</span>
<span class="sd">print(list(nx.edge_dfs(G,&#39;B&#39;, orientation=&#39;reverse&#39;)))</span>
<span class="sd">print(upstream_edges(G,&quot;B&quot;))</span>
<span class="sd">print(upstream_edges_neighbors(G,&quot;B&quot;))</span>

<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="downstream_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.downstream_edges">[docs]</a><span class="k">def</span> <span class="nf">downstream_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span></div>
<div class="viewcode-block" id="downstream_edges_neighbors_not_exact"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.downstream_edges_neighbors_not_exact">[docs]</a><span class="k">def</span> <span class="nf">downstream_edges_neighbors_not_exact</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="upstream_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.upstream_edges">[docs]</a><span class="k">def</span> <span class="nf">upstream_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">edge_dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;reverse&#39;</span><span class="p">))]</span></div>
<div class="viewcode-block" id="upstream_edges_neighbors_slow"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.upstream_edges_neighbors_slow">[docs]</a><span class="k">def</span> <span class="nf">upstream_edges_neighbors_slow</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">edge_dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;reverse&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="upstream_edges_neighbors"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.upstream_edges_neighbors">[docs]</a><span class="k">def</span> <span class="nf">upstream_edges_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="downstream_edges_neighbors"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.downstream_edges_neighbors">[docs]</a><span class="k">def</span> <span class="nf">downstream_edges_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="n">neighb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([[</span><span class="n">node</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">neighb</span><span class="p">),</span><span class="n">neighb</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

<div class="viewcode-block" id="downstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="n">downstream_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downstream_edges_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">downstream_results</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">downstream_results</span></div>
    

    
<div class="viewcode-block" id="n_downstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: xu.n_downstream_nodes(neuron_obj[0].concept_network_directional,18)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span></div>

<div class="viewcode-block" id="all_downstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">include_self</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_empty_list_if_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">curr_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span><span class="p">:</span>
        <span class="n">return_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">[</span><span class="n">curr_nodes</span><span class="o">!=</span><span class="n">node</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">return_empty_list_if_none</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">return_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">return_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">return_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_nodes</span></div>
        
<div class="viewcode-block" id="n_all_downstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_all_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span></div>
<div class="viewcode-block" id="all_downstream_nodes_including_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_downstream_nodes_including_node">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_nodes_including_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="all_downstream_nodes_from_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_downstream_nodes_from_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_nodes_from_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find all downstream nodes</span>
<span class="sd">    in group of nodes </span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each node:</span>
<span class="sd">    1) Get all of the downstream nodes</span>
<span class="sd">    2) add to the final list</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.all_downstream_nodes_from_nodes(limb_obj.concept_network_directional,[9,18])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes_including_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">d_nodes</span></div>


<span class="c1"># ---- upstream version of all nodes ----------</span>
<div class="viewcode-block" id="all_upstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_upstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">include_self</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">curr_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">upstream_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_self</span><span class="p">:</span>
        <span class="n">curr_nodes</span> <span class="o">=</span> <span class="n">curr_nodes</span><span class="p">[</span><span class="n">curr_nodes</span><span class="o">!=</span><span class="n">node</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_all_upstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_all_upstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_all_upstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_upstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span></div>
<div class="viewcode-block" id="all_upstream_nodes_including_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_upstream_nodes_including_node">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_nodes_including_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_upstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="all_upstream_nodes_from_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_upstream_nodes_from_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_nodes_from_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find all downstream nodes</span>
<span class="sd">    in group of nodes </span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each node:</span>
<span class="sd">    1) Get all of the downstream nodes</span>
<span class="sd">    2) add to the final list</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.all_downstream_nodes_from_nodes(limb_obj.concept_network_directional,[9,18])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">all_upstream_nodes_including_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">d_nodes</span></div>

    
<div class="viewcode-block" id="parent_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.parent_node">[docs]</a><span class="k">def</span> <span class="nf">parent_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="sibling_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.sibling_nodes">[docs]</a><span class="k">def</span> <span class="nf">sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="n">parent_node</span> <span class="o">=</span> <span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1">#find the sibling nodes</span>
    <span class="n">all_sibling_nodes</span> <span class="o">=</span> <span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">parent_node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_sibling_nodes</span><span class="p">[</span><span class="n">all_sibling_nodes</span> <span class="o">!=</span> <span class="n">node</span><span class="p">]</span></div>

<div class="viewcode-block" id="n_sibling_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_sibling_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="upstream_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.upstream_node">[docs]</a><span class="k">def</span> <span class="nf">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">return_single</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">curr_upstream_nodes</span> <span class="o">=</span> <span class="n">upstream_edges_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_upstream_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_upstream_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_single</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one upstream node for node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">curr_upstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_upstream_nodes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">curr_upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">curr_upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr_upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr_upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="all_parent_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_parent_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_parent_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the all parent nodes</span>
<span class="sd">    of a certain node (can be multiple)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reverse_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">traversal</span><span class="o">.</span><span class="n">bfs_tree</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">depth_limit</span> <span class="o">=</span> <span class="n">depth_limit</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">reverse_tree</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="all_children_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_children_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_children_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the all parent nodes</span>
<span class="sd">    of a certain node (can be multiple)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reverse_tree</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">traversal</span><span class="o">.</span><span class="n">bfs_tree</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">depth_limit</span> <span class="o">=</span> <span class="n">depth_limit</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">reverse_tree</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="common_relational_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.common_relational_nodes">[docs]</a><span class="k">def</span> <span class="nf">common_relational_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">relation</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="s2">&quot;intersect&quot;</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find common parent nodes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For all nodes:</span>
<span class="sd">    1) Find the parent nodes</span>

<span class="sd">    Get the intersection</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">array_like</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="n">common_nodes_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;all_</span><span class="si">{</span><span class="n">relation</span><span class="si">}</span><span class="s2">_nodes&quot;</span><span class="p">)(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">depth_limit</span><span class="o">=</span><span class="n">depth_limit</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">combining_method</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
         <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">combining_method</span><span class="si">}</span><span class="s2">1d_multi_list&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">combining_method</span>

    <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">common_nodes_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_common_nodes of </span><span class="si">{</span><span class="n">relation</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">common_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (after </span><span class="si">{</span><span class="n">combining_method</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">common_nodes</span></div>

<div class="viewcode-block" id="common_parent_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.common_parent_nodes">[docs]</a><span class="k">def</span> <span class="nf">common_parent_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="s2">&quot;intersect&quot;</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.common_parent_nodes(</span>
<span class="sd">        G,</span>
<span class="sd">        nodes = [&quot;864691134884741626_0&quot;,&quot;864691136226945617_0&quot;],</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">common_relational_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
    <span class="n">relation</span> <span class="o">=</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="n">combining_method</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="n">depth_limit</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="n_common_parent_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_common_parent_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_common_parent_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="s2">&quot;intersect&quot;</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">common_parent_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">combining_method</span> <span class="o">=</span> <span class="n">combining_method</span><span class="p">,</span>
            <span class="n">depth_limit</span> <span class="o">=</span> <span class="n">depth_limit</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="common_children_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.common_children_nodes">[docs]</a><span class="k">def</span> <span class="nf">common_children_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="s2">&quot;intersect&quot;</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">common_relational_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
    <span class="n">relation</span> <span class="o">=</span> <span class="s2">&quot;children&quot;</span><span class="p">,</span>
    <span class="n">combining_method</span> <span class="o">=</span> <span class="n">combining_method</span><span class="p">,</span>
    <span class="n">depth_limit</span> <span class="o">=</span> <span class="n">depth_limit</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>
       
    
<span class="c1"># --------------------- 8/31 -------------------------- #</span>
<span class="c1">#import random</span>


<div class="viewcode-block" id="hierarchy_pos"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.hierarchy_pos">[docs]</a><span class="k">def</span> <span class="nf">hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">vert_gap</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">vert_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span><span class="n">width_min</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span><span class="n">width_noise_ampl</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    </span>
<span class="sd">    Old presets: </span>
<span class="sd">    width=1., vert_gap = 0.2, vert_loc = 0, xcenter = 0.5</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    From Joel&#39;s answer at https://stackoverflow.com/a/29597209/2966723.  </span>
<span class="sd">    Licensed under Creative Commons Attribution-Share Alike </span>

<span class="sd">    If the graph is a tree this will return the positions to plot this in a </span>
<span class="sd">    hierarchical layout.</span>

<span class="sd">    G: the graph (must be a tree)</span>

<span class="sd">    root: the root node of current branch </span>
<span class="sd">    - if the tree is directed and this is not given, </span>
<span class="sd">      the root will be found and used</span>
<span class="sd">    - if the tree is directed and this is given, then </span>
<span class="sd">      the positions will be just for the descendants of this node.</span>
<span class="sd">    - if the tree is undirected and not given, </span>
<span class="sd">      then a random choice will be used.</span>

<span class="sd">    width: horizontal space allocated for this branch - avoids overlap with other branches</span>

<span class="sd">    vert_gap: gap between levels of hierarchy</span>

<span class="sd">    vert_loc: vertical location of root</span>

<span class="sd">    xcenter: horizontal location of root</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot use hierarchy_pos on a graph that is not a tree&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">):</span>
            <span class="n">root</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span>  <span class="c1">#allows back compatibility with nx version 1.11</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">vert_gap</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">vert_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        see hierarchy_pos docstring for most arguments</span>

<span class="sd">        pos: a dict saying where all nodes go if they have been assigned</span>
<span class="sd">        parent: parent of this branch. - only affects it if non-directed</span>

<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">width_min</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">width_min</span> <span class="o">+</span> <span class="n">width_noise_ampl</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#width = width_min </span>
            <span class="c1">#print(f&quot;width_noise_ampl = {width_noise_ampl}&quot;)</span>
        
        <span class="c1">#print(f&quot;root {root}: inside _hierarchy_pos: width = {width}, xcenter={xcenter}&quot;)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="p">:(</span><span class="n">xcenter</span><span class="p">,</span><span class="n">vert_loc</span><span class="p">)}</span> <span class="c1">#if no previous position then start dictioanry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xcenter</span><span class="p">,</span> <span class="n">vert_loc</span><span class="p">)</span> <span class="c1">#if dictionary already exists then add position to dictionary</span>
        <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="c1">#get all children of current root</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">)</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="c1">#remove parent from possible neighbors (so only get ones haven&#39;t used) </span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#if have children to graph</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">width</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>  <span class="c1">#take whole width and allocates for how much each child gets</span>
            <span class="n">nextx</span> <span class="o">=</span> <span class="n">xcenter</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">nextx</span> <span class="o">+=</span> <span class="n">dx</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                How recursive call works: </span>
<span class="sd">                1) the dx allocated for each child becomes the next width</span>
<span class="sd">                2) same vertical gap</span>
<span class="sd">                3) New vertical location is original but stepped down vertical gap</span>
<span class="sd">                3) New x location is the nextx</span>
<span class="sd">                </span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">_hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">child</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">dx</span><span class="p">,</span> <span class="n">vert_gap</span> <span class="o">=</span> <span class="n">vert_gap</span><span class="p">,</span> 
                                    <span class="n">vert_loc</span> <span class="o">=</span> <span class="n">vert_loc</span><span class="o">-</span><span class="n">vert_gap</span><span class="p">,</span> <span class="n">xcenter</span><span class="o">=</span><span class="n">nextx</span><span class="p">,</span>
                                    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos</span>


    <span class="k">return</span> <span class="n">_hierarchy_pos</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">vert_gap</span><span class="p">,</span> <span class="n">vert_loc</span><span class="p">,</span> <span class="n">xcenter</span><span class="p">)</span></div>
    
    
<span class="c1"># --------- 9/17 Addition ----------------------- #</span>
<span class="c1">#from copy import deepcopy</span>
<div class="viewcode-block" id="shortest_path_between_two_sets_of_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_between_two_sets_of_nodes">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node_list_1</span><span class="p">,</span>
    <span class="n">node_list_2</span><span class="p">,</span>
    <span class="n">return_node_pairs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_path_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Algorithm that will find the shortest path from a set of one</span>
<span class="sd">    list of nodes on a graph and another set of nodes:</span>
<span class="sd">    </span>
<span class="sd">    Returns: The shortest path, the nodes from each set that were paired</span>
<span class="sd">    </span>
<span class="sd">    Things to think about:</span>
<span class="sd">    - could possibly have non-overlapping groups</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    0) Make a copy of the graph</span>
<span class="sd">    1) Add a new node to graph that is connected to all nodes in node_list_1 (s)</span>
<span class="sd">    2) Add a new node to graph that is connected to all nodes in node_list_2 (t)</span>
<span class="sd">    3) Find shortest path from s to t</span>
<span class="sd">    4) remove s and t from path and return the two endpoints of path as node pair</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    G = nx.path_graph(10)</span>
<span class="sd">    node_list_1 = [1,2]</span>
<span class="sd">    node_list_2 = [9,5]</span>
<span class="sd">    </span>
<span class="sd">    shortest_path_between_two_sets_of_nodes(G,node_list_1,node_list_2,</span>
<span class="sd">                                           return_node_pairs=True)</span>
<span class="sd">    </span>
<span class="sd">    will return [ 2, 3, 4, 5],2,5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#0) Make a copy of the graph</span>
    <span class="n">G_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="c1">#node_number_max = np.max(G.nodes())</span>

    <span class="c1">#1) Add a new node to graph that is connected to all nodes in node_list_1 (s)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;node_source_1&quot;</span> <span class="c1">#node_number_max + 1</span>
    <span class="n">G_copy</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="mf">0.0001</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_list_1</span><span class="p">])</span>

    <span class="c1">#2) Add a new node to graph that is connected to all nodes in node_list_2 (t)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;node_target_2&quot;</span> <span class="c1">#node_number_max + 2</span>
    <span class="n">G_copy</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mf">0.0001</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_list_2</span><span class="p">])</span>

    <span class="c1">#3) Find shortest path from s to t</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G_copy</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
    

    <span class="c1">#node_pair</span>
    <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_node_1</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">end_node_2</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="c1">#make sure it is the shortest path between end nodes</span>
    <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">end_node_1</span><span class="p">,</span><span class="n">end_node_2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_path_distance</span><span class="p">:</span>
        <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">path_distance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">curr_shortest_path</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shortest path = </span><span class="si">{</span><span class="n">curr_shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_node_pairs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_shortest_path</span><span class="p">,</span><span class="n">end_node_1</span><span class="p">,</span><span class="n">end_node_2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_shortest_path</span></div>
    
    
<div class="viewcode-block" id="find_nodes_within_certain_distance_of_target_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.find_nodes_within_certain_distance_of_target_node">[docs]</a><span class="k">def</span> <span class="nf">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                      <span class="n">target_node</span><span class="p">,</span>
                                                        <span class="n">cutoff_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                                        <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Find the node values that are within a certain </span>
<span class="sd">    distance of a target node </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distance_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">target_node</span><span class="p">,</span>
                                                          <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff_distance</span>
                                                         <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">distance_dict</span>
    
    <span class="n">close_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">distance_dict</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">close_nodes</span></div>
    
    
<div class="viewcode-block" id="add_new_coordinate_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.add_new_coordinate_node">[docs]</a><span class="k">def</span> <span class="nf">add_new_coordinate_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
    <span class="n">node_coordinate</span><span class="p">,</span>
    <span class="n">replace_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replace_coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">node_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">return_node_id</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To add a node to a graph</span>
<span class="sd">    with just a coordinate and potentially replacing </span>
<span class="sd">    another node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#G = copy.deepcopy(G)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">replace_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">replace_coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">replace_coordinates</span><span class="o">=</span><span class="n">replace_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            
        <span class="n">replace_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">replace_coordinates</span><span class="p">]</span>

<span class="c1">#     print(f&quot;replace_coordinates = {replace_coordinates}&quot;)</span>
<span class="c1">#     print(f&quot;replace_nodes = {replace_nodes}&quot;)</span>
<span class="c1">#     print(f&quot;len(G) = {len(G)}&quot;)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">replace_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">replace_nodes</span><span class="p">):</span>
            <span class="n">replace_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">replace_nodes</span><span class="p">]</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">replace_nodes</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="n">node_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span><span class="n">coordinates</span><span class="o">=</span><span class="n">node_coordinate</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="n">node_id</span><span class="p">,</span><span class="n">k</span><span class="p">,</span>
             <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_coordinate</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">replace_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">replace_nodes</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_node_id</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">,</span><span class="n">node_id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span></div>
    

<div class="viewcode-block" id="move_node_from_exclusion_list"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.move_node_from_exclusion_list">[docs]</a><span class="k">def</span> <span class="nf">move_node_from_exclusion_list</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                  <span class="n">exclusion_list</span><span class="p">,</span>
                                 <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">node_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">return_coordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To move a point off of an exclusion list to another node</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Check if current node is in exclusion, if not then return</span>
<span class="sd">    2) Check if any of the neighbors are in exclusion, if not then return that</span>
<span class="sd">    3) If still havent found, then find the shortest path from stitch node to all non-exclude nodes</span>

<span class="sd">    Ex:</span>
<span class="sd">    </span>
<span class="sd">    move_node_from_exclusion_list(</span>
<span class="sd">    G = sk.convert_skeleton_to_graph(ex_skeleton),</span>
<span class="sd">    exclusion_list = np.array([[756852., 948046., 874045.],</span>
<span class="sd">             [756851., 948250., 874012.]]),</span>
<span class="sd">    node = None,</span>
<span class="sd">    node_coordinate = np.array([756851., 948250., 874012.]),</span>
<span class="sd">    return_coordinate = False,</span>
<span class="sd">    verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exclusion_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exclusion_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclusion_list</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">exclusion_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">return_neg_one_if_not_find</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exclusion_nodes</span> <span class="o">=</span> <span class="n">exclusion_list</span>

    <span class="k">if</span> <span class="n">node_coordinate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>   
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;both node and node coordinate are none&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">node_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_coordinate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1">#1) Check if current node is in exclusion, if not then return</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> was not in exlusion list so just returning that&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_coordinate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node_coordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>



    <span class="c1">#2) Check if any of the neighbors are in exclusion, if not then return that</span>
    <span class="n">node_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    <span class="n">viable_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">node_neighbors</span><span class="p">,</span><span class="n">exclusion_nodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found coordinate to move to in viable neighbors: </span><span class="si">{</span><span class="n">viable_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_coordinate</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">ex_skeleton_graph</span><span class="p">,</span><span class="n">viable_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">viable_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#3) If still havent found, then find the shortest path from stitch node to all non-exclude nodes</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">viable_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">,</span><span class="n">exclusion_nodes</span><span class="p">)</span>

    <span class="n">path</span><span class="p">,</span><span class="n">st_node</span><span class="p">,</span><span class="n">winning_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_list_1</span><span class="o">=</span><span class="p">[</span><span class="n">node</span><span class="p">],</span>
                                               <span class="n">node_list_2</span><span class="o">=</span><span class="n">viable_nodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Used the shortest path algorithm to find the winning node: </span><span class="si">{</span><span class="n">winning_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_coordinate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">winning_node</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">winning_node</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="connected_components_from_nodes_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.connected_components_from_nodes_edges">[docs]</a><span class="k">def</span> <span class="nf">connected_components_from_nodes_edges</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return groups that should be connected</span>
<span class="sd">    as defined by the total nodes and edges between nodes</span>
<span class="sd">    </span>
<span class="sd">    connected_components_from_nodes_edges([1,2,3,4,5,6],</span>
<span class="sd">                                     [[1,3],</span>
<span class="sd">                                     [3,5],</span>
<span class="sd">                                     [5,6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))]</span></div>

<div class="viewcode-block" id="nodes_in_kept_group"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_in_kept_group">[docs]</a><span class="k">def</span> <span class="nf">nodes_in_kept_group</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                       <span class="n">nodes_to_keep</span><span class="p">,</span>
                        <span class="n">return_removed_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the nodes that are in the same connected component</span>
<span class="sd">    as at least one of the nodes in the keep group</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">nodes_to_keep</span><span class="p">):</span>
        <span class="n">keep_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes_to_keep</span><span class="p">]</span>
        
        
    <span class="c1">#2) Split the graph into connected components</span>
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp = </span><span class="si">{</span><span class="n">conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) Find all kept nodes as the connected component with </span>
    <span class="c1">#the starting node (if there is one)</span>
    <span class="n">nodes_kept</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nodes_removed</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">:</span>
        <span class="n">intersecting_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nodes_to_keep</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;intersecting_nodes = </span><span class="si">{</span><span class="n">intersecting_nodes</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">keep_nodes</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersecting_nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nodes_kept</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes_removed</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_removed_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_kept</span><span class="p">,</span><span class="n">nodes_removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_kept</span></div>

    

<div class="viewcode-block" id="nodes_in_kept_groups_after_deletion"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_in_kept_groups_after_deletion">[docs]</a><span class="k">def</span> <span class="nf">nodes_in_kept_groups_after_deletion</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                       <span class="n">nodes_to_keep</span><span class="p">,</span>
                                        <span class="n">nodes_to_remove</span><span class="p">,</span>
                                        <span class="n">return_removed_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To delete nodes from a graph and then only return the </span>
<span class="sd">    nodes that are still connected to a certain group of nodes</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    1) Delete all the nodes from the graph</span>
<span class="sd">    2) Split the graph into connected components</span>
<span class="sd">    3) Find all kept nodes as the connected component with </span>
<span class="sd">    the starting node (if there is one)</span>
<span class="sd">    4) Return either the kept nodes (and optionally the deleted ones)</span>
<span class="sd">    </span>
<span class="sd">    Application:</span>
<span class="sd">    If have starting node in limb concept network, and want to delete</span>
<span class="sd">    certain nodes, will tell you what nodes will still be connected</span>
<span class="sd">    to starting node after deletion</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    G = nx.Graph(curr_limb.concept_network_directional)</span>
<span class="sd">    nodes_to_keep = 0</span>
<span class="sd">    nodes_to_remove = [6,13]</span>

<span class="sd">    xu.nodes_in_kept_groups_after_deletion(G,</span>
<span class="sd">                                        nodes_to_keep,</span>
<span class="sd">                                           nodes_to_remove=nodes_to_remove,</span>
<span class="sd">                                        return_removed_nodes = True</span>
<span class="sd">                                           )  </span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1">#1) Delete all the nodes from the graph</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>
    
    <span class="n">nodes_removed_manually</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>
    
    <span class="n">nodes_kept</span><span class="p">,</span><span class="n">nodes_removed</span> <span class="o">=</span> <span class="n">nodes_in_kept_group</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                       <span class="n">nodes_to_keep</span><span class="p">,</span>
                        <span class="n">return_removed_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                       <span class="p">)</span>
    <span class="n">nodes_removed</span> <span class="o">+=</span> <span class="n">nodes_removed_manually</span>
    
    <span class="k">if</span> <span class="n">return_removed_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_kept</span><span class="p">,</span><span class="n">nodes_removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes_kept</span></div>
<span class="w">        </span>

<span class="sd">&#39;&#39;&#39;  Old method before extracting out function</span>
<span class="sd">def nodes_in_kept_groups_after_deletion(G,</span>
<span class="sd">                                       nodes_to_keep,</span>
<span class="sd">                                        nodes_to_remove,</span>
<span class="sd">                                        return_removed_nodes = False,</span>
<span class="sd">                                        verbose = False,</span>
<span class="sd">                                       ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To delete nodes from a graph and then only return the </span>
<span class="sd">    nodes that are still connected to a certain group of nodes</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    1) Delete all the nodes from the graph</span>
<span class="sd">    2) Split the graph into connected components</span>
<span class="sd">    3) Find all kept nodes as the connected component with </span>
<span class="sd">    the starting node (if there is one)</span>
<span class="sd">    4) Return either the kept nodes (and optionally the deleted ones)</span>
<span class="sd">    </span>
<span class="sd">    Application:</span>
<span class="sd">    If have starting node in limb concept network, and want to delete</span>
<span class="sd">    certain nodes, will tell you what nodes will still be connected</span>
<span class="sd">    to starting node after deletion</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    G = nx.Graph(curr_limb.concept_network_directional)</span>
<span class="sd">    nodes_to_keep = 0</span>
<span class="sd">    nodes_to_remove = [6,13]</span>

<span class="sd">    xu.nodes_in_kept_groups_after_deletion(G,</span>
<span class="sd">                                        nodes_to_keep,</span>
<span class="sd">                                           nodes_to_remove=nodes_to_remove,</span>
<span class="sd">                                        return_removed_nodes = True</span>
<span class="sd">                                           )  </span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    G = nx.Graph(G)</span>

<span class="sd">    if not nu.is_array_like(nodes_to_keep):</span>
<span class="sd">        keep_nodes = [nodes_to_keep]</span>

<span class="sd">    #1) Delete all the nodes from the graph</span>
<span class="sd">    G.remove_nodes_from(nodes_to_remove)</span>

<span class="sd">    #2) Split the graph into connected components</span>
<span class="sd">    conn_comp = list(nx.connected_components(G))</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;conn_comp = {conn_comp}&quot;)</span>

<span class="sd">    #3) Find all kept nodes as the connected component with </span>
<span class="sd">    #the starting node (if there is one)</span>
<span class="sd">    nodes_kept = []</span>
<span class="sd">    nodes_removed = list(nodes_to_remove)</span>

<span class="sd">    for c in conn_comp:</span>
<span class="sd">        intersecting_nodes = np.intersect1d(nodes_to_keep,list(c))</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;intersecting_nodes = {intersecting_nodes} of {keep_nodes} and {c}&quot;)</span>
<span class="sd">        if len(intersecting_nodes)&gt;0:</span>
<span class="sd">            nodes_kept += list(c)</span>
<span class="sd">        else:</span>
<span class="sd">            nodes_removed += list(c)</span>

<span class="sd">    if return_removed_nodes:</span>
<span class="sd">        return nodes_kept,nodes_removed</span>
<span class="sd">    else:</span>
<span class="sd">        return nodes_kept</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    
<div class="viewcode-block" id="all_path_from_start_to_end_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_path_from_start_to_end_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_path_from_start_to_end_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the end nodes</span>
<span class="sd">    2) Subtract the starting node from the end nodes (if it is in there)</span>

<span class="sd">    If the list is longer than 0, iterate through all end nodes</span>
<span class="sd">    a. Get the shortest path from end node to the start node</span>

<span class="sd">    Return all of the paths</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">curr_endnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">curr_endnodes_to_test</span> <span class="o">=</span> <span class="n">curr_endnodes</span><span class="p">[</span><span class="n">curr_endnodes</span> <span class="o">!=</span> <span class="n">start_node</span><span class="p">]</span>

    <span class="n">all_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_node</span><span class="p">,</span><span class="n">e_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">e_node</span> <span class="ow">in</span> <span class="n">curr_endnodes_to_test</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">all_paths</span></div>

<span class="c1">#import copy</span>
<div class="viewcode-block" id="create_and_delete_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.create_and_delete_edges">[docs]</a><span class="k">def</span> <span class="nf">create_and_delete_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                        <span class="n">edges_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">edges_to_create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">perform_edge_rejection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_accepted_edges_to_create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add and delete edges of a graph</span>
<span class="sd">    with possibly enforcing edge rejection</span>
<span class="sd">    where if the edge created does connect any of the</span>
<span class="sd">    nodes that should not be connected like specified in edges_to_delete</span>
<span class="sd">    then rejects the edge</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">return_copy</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete (cut_limb_network) = </span><span class="si">{</span><span class="n">edges_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span>


    <span class="c1">#apply the winning cut</span>
    <span class="n">accepted_edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_to_create</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_create = </span><span class="si">{</span><span class="n">edges_to_create</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">perform_edge_rejection</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">edges_to_create</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">d1</span><span class="p">,</span><span class="n">d2</span> <span class="ow">in</span> <span class="n">edges_to_delete</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ex_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejected edge (</span><span class="si">{</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Accepted edge (</span><span class="si">{</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">accepted_edges_to_create</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accepted_edges_to_create</span> <span class="o">=</span> <span class="n">edges_to_create</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">accepted_edges_to_create</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_accepted_edges_to_create</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">,</span><span class="n">accepted_edges_to_create</span>

    <span class="k">return</span> <span class="n">G</span></div>

<span class="c1"># ------ 2/26: Used for helping for the lowest angle sum crossovers</span>
<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="all_subgraph_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_subgraph_edges">[docs]</a><span class="k">def</span> <span class="nf">all_subgraph_edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">all_subarrays</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span></div>

<div class="viewcode-block" id="all_subgraphs"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_subgraphs">[docs]</a><span class="k">def</span> <span class="nf">all_subgraphs</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will generate all of the subgraphs </span>
<span class="sd">    of a certain graph</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    for k in all_subgraphs(G):</span>
<span class="sd">        nx.draw(k,with_labels=True)</span>
<span class="sd">        plt.show()</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_subgraph_edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">G_copy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">G_copy</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G_copy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph_list</span></div>

<span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<div class="viewcode-block" id="sum_of_edge_weights"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.sum_of_edge_weights">[docs]</a><span class="k">def</span> <span class="nf">sum_of_edge_weights</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span></div>
<div class="viewcode-block" id="get_edges_with_weights"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edges_with_weights">[docs]</a><span class="k">def</span> <span class="nf">get_edges_with_weights</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]]</span> <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span></div>

<div class="viewcode-block" id="degree_1_max_edge_min_max_weight_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.degree_1_max_edge_min_max_weight_graph">[docs]</a><span class="k">def</span> <span class="nf">degree_1_max_edge_min_max_weight_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
    <span class="n">weight_metric</span> <span class="o">=</span> <span class="s2">&quot;lowest&quot;</span><span class="p">,</span> <span class="c1">#or highest</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_winning_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_edge_info</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To obtain the sugraph with the following properties</span>
<span class="sd">    1) Every node has at most one edge</span>
<span class="sd">    2) The highest number of edges with property 1</span>
<span class="sd">    3) The lowest/highest overall weight wiwth property 2</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all the subgraph possibilites</span>
<span class="sd">    2) Find highest degree nodes od each graph </span>
<span class="sd">    and filter those away that are greater than 1</span>
<span class="sd">    3) Find the highest edge count and filter</span>
<span class="sd">    away those with less </span>
<span class="sd">    4) Pick the graph with the lowest or highest total weight</span>
<span class="sd">    5) Have option to output Graph or the edges and the weights </span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    </span>
<span class="sd">    G = nx.Graph()</span>
<span class="sd">    G.add_weighted_edges_from([[1,4,20],</span>
<span class="sd">                              [1,3,10],</span>
<span class="sd">                              [2,3,40]])</span>
<span class="sd">    nx.draw(G,with_labels=True)</span>

<span class="sd">    return_info = xu.degree_1_max_edge_min_max_weight_graph(</span>
<span class="sd">        G = G,</span>
<span class="sd">        verbose = False,</span>
<span class="sd">        plot_winning_graph = True,</span>
<span class="sd">    return_edge_info=True)</span>
<span class="sd">    return_info</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#1) Find all the subgraph possibilites</span>
    <span class="n">all_subgraphs</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_subgraphs</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># 2) Find highest degree nodes od each graph </span>
    <span class="c1"># and filter those away that are greater than 1</span>
    <span class="n">subgraphs_degree_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_subgraphs</span> <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">max_node_degree</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraphs_degree_filtered= </span><span class="si">{</span><span class="n">subgraphs_degree_filtered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# subgraphs Graphs after degree  = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subgraphs_degree_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) Find the highest edge count and filter</span>
    <span class="c1">#away those with less </span>
    <span class="n">subgraphs_n_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_edges</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subgraphs_degree_filtered</span><span class="p">])</span>
    <span class="n">subgraphs_n_edges_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">subgraphs_n_edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraphs_n_edges_max = </span><span class="si">{</span><span class="n">subgraphs_n_edges_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">subgraphs_edges_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subgraphs_degree_filtered</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">subgraphs_n_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">subgraphs_n_edges_max</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# subgraphs Graphs with max edges (</span><span class="si">{</span><span class="n">subgraphs_n_edges_max</span><span class="si">}</span><span class="s2">)  = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">subgraphs_edges_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#4) Pick the graph with the lowest or highest total weight</span>
    <span class="n">sugraph_edge_weight_sum</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">sum_of_edge_weights</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subgraphs_edges_filtered</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">weight_metric</span> <span class="o">==</span> <span class="s2">&quot;lowest&quot;</span><span class="p">:</span>
        <span class="n">winning_G_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sugraph_edge_weight_sum</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weight_metric</span> <span class="o">==</span> <span class="s2">&quot;highest&quot;</span><span class="p">:</span>
        <span class="n">winning_G_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sugraph_edge_weight_sum</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Exeption</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown weight metric: </span><span class="si">{</span><span class="n">weight_metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">winning_graph</span> <span class="o">=</span> <span class="n">subgraphs_edges_filtered</span><span class="p">[</span><span class="n">winning_G_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_winning_graph</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;N_edges for winning graph = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">n_edges</span><span class="p">(</span><span class="n">winning_graph</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">winning_graph</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_edge_info</span><span class="p">:</span>
        <span class="n">edges_with_weights</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_edges_with_weights</span><span class="p">(</span><span class="n">winning_graph</span><span class="p">)</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">edges_with_weights</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">],</span><span class="n">edges_with_weights</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">winning_graph</span>

    <span class="k">return</span> <span class="n">return_value</span></div>

<span class="k">def</span> <span class="nf">edges_and_weights_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>
    <span class="n">edges_with_weights</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">weights</span><span class="p">)]</span>
    <span class="n">edges_with_weights</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges_with_weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span>

<div class="viewcode-block" id="lowest_weighted_sum_singular_matches"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.lowest_weighted_sum_singular_matches">[docs]</a><span class="k">def</span> <span class="nf">lowest_weighted_sum_singular_matches</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_weights</span><span class="p">,</span>
                                        <span class="n">plot_winning_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    will attempt to pair every node with another node</span>
<span class="sd">    so that the sum of the weights on the graph are as low as possible</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_branches_G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges_and_weights_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span>
                                                    <span class="n">edges_weights</span><span class="p">)</span>
    <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">degree_1_max_edge_min_max_weight_graph</span><span class="p">(</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">curr_branches_G</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="n">plot_winning_graph</span> <span class="o">=</span> <span class="n">plot_winning_graph</span><span class="p">,</span>
                <span class="n">return_edge_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span></div>

<div class="viewcode-block" id="get_edge_weight"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edge_weight">[docs]</a><span class="k">def</span> <span class="nf">get_edge_weight</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="graph_to_edges_and_weights"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_to_edges_and_weights">[docs]</a><span class="k">def</span> <span class="nf">graph_to_edges_and_weights</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn a graph into a list of edges</span>
<span class="sd">    and a list of weights for the edges</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
    <span class="n">weight_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_edge_weight</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">edge_list</span><span class="p">,</span><span class="n">weight_list</span></div>

<div class="viewcode-block" id="edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edges">[docs]</a><span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span></div>

<div class="viewcode-block" id="edges_and_weights_to_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edges_and_weights_to_graph">[docs]</a><span class="k">def</span> <span class="nf">edges_and_weights_to_graph</span><span class="p">(</span>
    <span class="n">edges_list</span><span class="p">,</span>
    <span class="n">weights_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weights_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_list</span><span class="p">))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges_list</span><span class="p">,</span><span class="n">weights_list</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="graph_to_lowest_weighted_sum_singular_matches"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_to_lowest_weighted_sum_singular_matches">[docs]</a><span class="k">def</span> <span class="nf">graph_to_lowest_weighted_sum_singular_matches</span><span class="p">(</span><span class="n">G</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">edges_weights</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_graph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a Graph</span>
<span class="sd">    or list of edges and a list of their weights</span>
<span class="sd">    and to determine the singular pairings</span>
<span class="sd">    that result in the lowest total sum of weights</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Turn the matched branhes and the match_branches_angle</span>
<span class="sd">    into a weighted graph</span>
<span class="sd">    2) Get the lowest weight graph and output the edges</span>
<span class="sd">    3) Turn to lists and reassign as the matched branches</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">edges_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges</span><span class="p">,</span><span class="n">edges_weights</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">graph_to_edges_and_weights</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span>  <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">lowest_weighted_sum_singular_matches</span><span class="p">(</span>
                                                                <span class="n">edges</span><span class="p">,</span>
                                                                <span class="n">edges_weights</span><span class="p">)</span>
    <span class="n">match_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">match_branches</span><span class="p">)</span>
    <span class="n">match_branches_angle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">match_branches_angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From lowest_angle_sum_singular_pair: </span><span class="se">\n</span><span class="s2">match_branches = </span><span class="si">{</span><span class="n">match_branches</span><span class="si">}</span><span class="s2">,match_branches_angle = </span><span class="si">{</span><span class="n">match_branches_angle</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_graph</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges_and_weights_to_graph</span><span class="p">(</span><span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span></div>
    
<div class="viewcode-block" id="get_neighbor_min_weighted_edge"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_neighbor_min_weighted_edge">[docs]</a><span class="k">def</span> <span class="nf">get_neighbor_min_weighted_edge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to pick the </span>
<span class="sd">    neighbor of a node with the lowest weight</span>

<span class="sd">    Psuedocode:</span>
<span class="sd">    1) get the neighbors</span>
<span class="sd">    --&gt; if list empty then return none</span>
<span class="sd">    2) get the weights of the neighbor</span>
<span class="sd">    3) get the argmin of the weights</span>
<span class="sd">    4) return the min neighbor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No neighbors so returning None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
    <span class="n">n_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_edge_weight</span><span class="p">(</span><span class="n">G</span><span class="p">,(</span><span class="n">node</span><span class="p">,</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neighbors = </span><span class="si">{</span><span class="n">neighbors</span><span class="si">}</span><span class="s2">, neighbor weights = </span><span class="si">{</span><span class="n">n_weights</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">min_neighbor</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">n_weights</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_neighbor = </span><span class="si">{</span><span class="n">min_neighbor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">min_neighbor</span></div>


<div class="viewcode-block" id="group_nodes_into_siblings"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.group_nodes_into_siblings">[docs]</a><span class="k">def</span> <span class="nf">group_nodes_into_siblings</span><span class="p">(</span><span class="n">G</span> <span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To group a list of branches</span>
<span class="sd">    into groups if they are sibling branches</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) For each branch get a list of the sibling branches</span>
<span class="sd">    and turn them into edges</span>
<span class="sd">    2) Create a graph from the edges</span>
<span class="sd">    3) Divide into connected components and return</span>

<span class="sd">    Ex:</span>
<span class="sd">    xu.group_nodes_into_siblings(G = neuron_obj[0].concept_network_directional,</span>
<span class="sd">    nodes = [14,  2,  4, 23, 25],</span>
<span class="sd">    verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">all_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">curr_sibs</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="n">all_edges</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">curr_sibs</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All sibling edges = </span><span class="si">{</span><span class="n">all_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Create a graph from the edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">all_edges</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)]</span></div>

<div class="viewcode-block" id="all_edges_on_shortest_paths_between_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_edges_on_shortest_paths_between_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_edges_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given a group of nodes, find </span>
<span class="sd">    all edges that constitute the shortest paths</span>
<span class="sd">    between all pairs of nodes in the list</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_to_s_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">source_comb</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">all_unique_choose_2_combinations</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="ow">in</span> <span class="n">source_comb</span><span class="p">:</span>
        
        <span class="n">curr_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span>
                                            <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="n">path_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">curr_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">curr_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">s_to_s_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_edges</span><span class="p">)</span>
        
<span class="c1">#         if 15 in np.array(path_edges).ravel():</span>
<span class="c1">#             print(f&quot;s1 = {s1}, s2 = {s2}&quot;)</span>
<span class="c1">#             print(f&quot;path_edges = {path_edges}&quot;)</span>
<span class="c1">#             raise Exception(&quot;&quot;)</span>

    <span class="n">s_to_s_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">s_to_s_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s_to_s_edges</span></div>

<div class="viewcode-block" id="all_nodes_on_shortest_paths_between_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_nodes_on_shortest_paths_between_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_nodes_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes</span>
    <span class="n">s_to_s_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">all_edges_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">s_to_s_edges</span></div>

<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="min_cut_to_partition_node_groups"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.min_cut_to_partition_node_groups">[docs]</a><span class="k">def</span> <span class="nf">min_cut_to_partition_node_groups</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                     <span class="n">source_nodes</span><span class="p">,</span>
                                    <span class="n">sink_nodes</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the edges of graph that would</span>
<span class="sd">    need to be cut to completely partition</span>
<span class="sd">    all nodes in sink_nodes from nodes</span>
<span class="sd">    in source_nodes into seperate connected components</span>
<span class="sd">    </span>
<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get all of the shortest path edges between</span>
<span class="sd">    nodes in the same group (we will heavily weight them so they don&#39;t get cut)</span>
<span class="sd">    2) Add new nodes that will connect to every node in a specific partition</span>
<span class="sd">    (heavily weighted)</span>
<span class="sd">    3) Find the minimum cut between the two newly added nodes</span>
<span class="sd">    4) Return the edges of the original graph that went between</span>
<span class="sd">    the partition create for sink_nodes and source_nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">large_weight</span> <span class="o">=</span> <span class="mi">10000</span>

    <span class="c1">#0) copying the new graph with weights</span>
    <span class="n">G_orig</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G_orig</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>
    <span class="n">node_number_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>


    <span class="n">s_to_s_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_edges_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source_nodes</span><span class="p">)</span>
    <span class="n">si_to_si_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_edges_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">sink_nodes</span><span class="p">)</span>

    <span class="n">new_source</span> <span class="o">=</span> <span class="n">node_number_max</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">s_new_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">new_source</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">source_nodes</span><span class="p">]</span>

    <span class="n">new_sink</span> <span class="o">=</span> <span class="n">node_number_max</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">si_new_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">new_sink</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sink_nodes</span><span class="p">]</span>

    <span class="n">all_large_weight_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s_to_s_edges</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">si_to_si_edges</span><span class="p">)</span> <span class="o">+</span> <span class="n">s_new_edges</span> <span class="o">+</span> <span class="n">si_new_edges</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">+</span> <span class="p">[</span><span class="n">large_weight</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_large_weight_edges</span><span class="p">])</span>
    
    <span class="c1">#3) Find the minimum cut between the two newly added nodes</span>
    <span class="n">cut_weight</span><span class="p">,</span> <span class="n">partitions</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">new_source</span><span class="p">,</span> <span class="n">new_sink</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cut_weight = </span><span class="si">{</span><span class="n">cut_weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#4) Return the edges of the original graph that went between</span>
    <span class="c1">#the partition create for sink_nodes and source_nodes</span>
    <span class="n">edge_cut_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p1_node</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">p2_node</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">p1_node</span><span class="p">,</span><span class="n">p2_node</span><span class="p">):</span>
                <span class="n">edge_cut_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p1_node</span><span class="p">,</span><span class="n">p2_node</span><span class="p">])</span>
    <span class="n">edge_cut_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_cut_list</span><span class="p">)</span>
    
    <span class="n">nodes_in_edge_cut</span> <span class="o">=</span> <span class="n">edge_cut_list</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_in_edge_cut = </span><span class="si">{</span><span class="n">nodes_in_edge_cut</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">cut_weight</span> <span class="o">&gt;=</span> <span class="n">large_weight</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_cut_list</span></div>
<div class="viewcode-block" id="remove_inter_partition_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_inter_partition_edges">[docs]</a><span class="k">def</span> <span class="nf">remove_inter_partition_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                 <span class="n">partition</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="n">G1</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G1</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
        
        <span class="n">subgraph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">subgraph_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_edges_with_weights</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
            <span class="n">G1</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">subgraph_edges</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">G1</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">subgraph</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- For partition </span><span class="si">{</span><span class="n">p1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraph nodes = </span><span class="si">{</span><span class="n">subgraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subgraph_edges = </span><span class="si">{</span><span class="n">subgraph_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Edges = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_edges_with_weights</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Edges = </span><span class="si">{</span><span class="n">G1</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Nodes = </span><span class="si">{</span><span class="n">G1</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">G1</span></div>

<div class="viewcode-block" id="end_nodes_of_digraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.end_nodes_of_digraph">[docs]</a><span class="k">def</span> <span class="nf">end_nodes_of_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the nodes that</span>
<span class="sd">    do not have any downstream nodes </span>
<span class="sd">    (aka they are at the edge of the graph)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">end_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of end nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_nx_type"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_nx_type">[docs]</a><span class="k">def</span> <span class="nf">get_nx_type</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span></div>

<div class="viewcode-block" id="reverse_DiGraph_old"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.reverse_DiGraph_old">[docs]</a><span class="k">def</span> <span class="nf">reverse_DiGraph_old</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="c1">#return G.edges()</span>
    <span class="n">new_G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">get_nx_type</span><span class="p">(</span><span class="n">G</span><span class="p">))()</span>
    <span class="n">curr_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span>
    <span class="n">new_G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">curr_edges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_G</span></div>

<div class="viewcode-block" id="reverse_DiGraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.reverse_DiGraph">[docs]</a><span class="k">def</span> <span class="nf">reverse_DiGraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="connected_components"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.connected_components">[docs]</a><span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_subgraphs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">conn_comp_list</span>  <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">())]</span>
    
    <span class="k">if</span> <span class="n">return_subgraphs</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp_list</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_comp_list</span></div>
    
<div class="viewcode-block" id="connected_components_subgraphs"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.connected_components_subgraphs">[docs]</a><span class="k">def</span> <span class="nf">connected_components_subgraphs</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">return_subgraphs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1"># --------------------- 6/14: For help with queying graphs with datatables --------- #</span>
<span class="n">upstream_name</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span>
<span class="n">node_id_default</span> <span class="o">=</span> <span class="n">upstream_name</span>
<span class="n">downstream_name</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>
<span class="c1">#from python_tools import general_utils as gu</span>
<div class="viewcode-block" id="node_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.node_df">[docs]</a><span class="k">def</span> <span class="nf">node_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">properties_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">properties_to_include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">node_id</span> <span class="o">=</span> <span class="n">upstream_name</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To export the node properties  as a dataframe</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">],{</span><span class="n">node_id</span><span class="p">:</span><span class="n">k</span><span class="p">}])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
    <span class="n">node_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">dicts_to_dataframe</span><span class="p">(</span><span class="n">node_dict</span><span class="p">)</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">properties_to_include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">properties_to_include</span><span class="p">:</span>
            <span class="n">properties_to_include</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">properties_to_include</span><span class="p">,[</span><span class="n">node_id</span><span class="p">]])</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span><span class="n">properties_to_include</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">properties_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">col_names</span><span class="p">,</span><span class="n">properties_to_exclude</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for node_df = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">node_df</span><span class="p">[[</span><span class="n">node_id</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">col_names</span><span class="p">[</span><span class="n">col_names</span> <span class="o">!=</span> <span class="n">node_id</span><span class="p">])]</span></div>

<div class="viewcode-block" id="node_df_features"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.node_df_features">[docs]</a><span class="k">def</span> <span class="nf">node_df_features</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span></div>

<div class="viewcode-block" id="subgraph_from_node_query"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.subgraph_from_node_query">[docs]</a><span class="k">def</span> <span class="nf">subgraph_from_node_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                            <span class="n">query</span><span class="p">,</span>
                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return a subgraph induced</span>
<span class="sd">    by a query on the nodes</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span>
    <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="c1">#reduced_df = node_df.query(query)</span>
    <span class="n">reduced_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span><span class="n">query</span><span class="p">)</span>
    <span class="n">remaining_nodes</span> <span class="o">=</span> <span class="n">reduced_df</span><span class="p">[</span><span class="n">upstream_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">remaining_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="node_df_from_node_query"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.node_df_from_node_query">[docs]</a><span class="k">def</span> <span class="nf">node_df_from_node_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">query</span><span class="p">,</span><span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span>
    <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="c1">#reduced_df = node_df.query(query)</span>
    <span class="n">reduced_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span><span class="n">query</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reduced_df</span><span class="p">[</span><span class="n">upstream_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reduced_df</span></div>
    
<div class="viewcode-block" id="nodes_from_node_query"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_from_node_query">[docs]</a><span class="k">def</span> <span class="nf">nodes_from_node_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">query</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df_from_node_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">query</span><span class="p">,</span><span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span></div>
    
<span class="n">node_query</span> <span class="o">=</span> <span class="n">nodes_from_node_query</span>

<span class="c1">#from python_tools import general_utils as gu</span>
<span class="c1">#from python_tools.tqdm_utils import tqdm</span>
<span class="c1">#from python_tools import tqdm_utils as tqu</span>
<span class="c1">#import time</span>
<span class="c1">#import pandas as pd</span>
<span class="c1">#from . import numpy_dep as np</span>


<div class="viewcode-block" id="edge_df_multi"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_df_multi">[docs]</a><span class="k">def</span> <span class="nf">edge_df_multi</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                 <span class="n">with_node_attributes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will output the multi-edged</span>
<span class="sd">    graph edge dataframe accounting for multiple possible edges</span>
<span class="sd">    </span>
<span class="sd">    Currently does that same thing as xu.edge_df_optimized(G_proof_multi_di)</span>
<span class="sd">    except that it can export node properties</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from python_tools import networkx_utils as xu</span>
<span class="sd">    e_df = xu.edge_df_multi(G_proof_multi_di,</span>
<span class="sd">                            verbose = True,</span>
<span class="sd">                     )</span>
<span class="sd">    e_df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">total_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_off_tqdm</span><span class="p">()</span>
        
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">key</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total_edges</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">with_node_attributes</span><span class="p">:</span>
            <span class="n">u_dict</span> <span class="o">=</span>  <span class="n">gu</span><span class="o">.</span><span class="n">add_prefix_to_keys</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">upstream_name</span><span class="p">)</span>
            <span class="n">d_dict</span> <span class="o">=</span>  <span class="n">gu</span><span class="o">.</span><span class="n">add_prefix_to_keys</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">d</span><span class="p">],</span><span class="n">downstream_name</span><span class="p">)</span>
            <span class="n">node_sp_dict</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([{</span><span class="n">upstream_name</span><span class="p">:</span><span class="n">u</span><span class="p">,</span>
                                            <span class="n">downstream_name</span><span class="p">:</span><span class="n">d</span><span class="p">},</span><span class="n">u_dict</span><span class="p">,</span><span class="n">d_dict</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_sp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">upstream_name</span><span class="p">:</span><span class="n">u</span><span class="p">,</span>
                            <span class="n">downstream_name</span><span class="p">:</span><span class="n">d</span><span class="p">}</span>
            
        <span class="n">total_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span><span class="n">node_sp_dict</span><span class="p">,</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">d</span><span class="p">][</span><span class="n">key</span><span class="p">]]))</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Dict = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">G_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">total_dicts</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Dataframe = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_df</span></div>
    

<div class="viewcode-block" id="edge_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_df">[docs]</a><span class="k">def</span> <span class="nf">edge_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_node_attributes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">expand_to_all_multi_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To export the edges of a graph into</span>
<span class="sd">    a pandas dataframe so that later they can</span>
<span class="sd">    be queried easily</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">total_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_off_tqdm</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">expand_to_all_multi_edges</span><span class="p">:</span>
        <span class="n">multi_flag</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">multi_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total_edges</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">with_node_attributes</span><span class="p">:</span>
            <span class="n">u_dict</span> <span class="o">=</span>  <span class="n">gu</span><span class="o">.</span><span class="n">add_prefix_to_keys</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">upstream_name</span><span class="p">)</span>
            <span class="n">d_dict</span> <span class="o">=</span>  <span class="n">gu</span><span class="o">.</span><span class="n">add_prefix_to_keys</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">d</span><span class="p">],</span><span class="n">downstream_name</span><span class="p">)</span>
            <span class="n">node_sp_dict</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([{</span><span class="n">upstream_name</span><span class="p">:</span><span class="n">u</span><span class="p">,</span>
                                            <span class="n">downstream_name</span><span class="p">:</span><span class="n">d</span><span class="p">},</span><span class="n">u_dict</span><span class="p">,</span><span class="n">d_dict</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_sp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">upstream_name</span><span class="p">:</span><span class="n">u</span><span class="p">,</span>
                            <span class="n">downstream_name</span><span class="p">:</span><span class="n">d</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">multi_flag</span><span class="p">:</span>
            <span class="n">total_dicts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span><span class="n">node_sp_dict</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">edge_index</span><span class="o">=</span><span class="n">k</span><span class="p">)])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span><span class="n">node_sp_dict</span><span class="p">,</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">d</span><span class="p">]]))</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Dict = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">G_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">total_dicts</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Dataframe = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_df</span></div>


<span class="c1">#from python_tools import regex_utils as ru</span>
<div class="viewcode-block" id="query_bidirectional"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.query_bidirectional">[docs]</a><span class="k">def</span> <span class="nf">query_bidirectional</span><span class="p">(</span><span class="n">query</span><span class="p">,</span>
    <span class="n">node_1</span> <span class="o">=</span> <span class="n">upstream_name</span><span class="p">,</span>
    <span class="n">node_2</span><span class="o">=</span><span class="n">downstream_name</span><span class="p">,</span>
    <span class="n">logical_combination</span> <span class="o">=</span> <span class="s2">&quot;or&quot;</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To make a query apply to equal direction</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    query = &quot;u in [1,2,3,4] and v in [0,2,3]&quot;</span>
<span class="sd">    xu.query_bidirectional(query)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">replace_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_1</span><span class="p">:</span><span class="n">node_2</span><span class="p">,</span>
                  <span class="n">node_2</span><span class="p">:</span><span class="n">node_1</span><span class="p">}</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">logical_combination</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">ru</span><span class="o">.</span><span class="n">multiple_replace</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="n">replace_map</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span></div>

<div class="viewcode-block" id="is_digraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_digraph">[docs]</a><span class="k">def</span> <span class="nf">is_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;Di&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="is_multigraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_multigraph">[docs]</a><span class="k">def</span> <span class="nf">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;Multi&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="is_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_graph">[docs]</a><span class="k">def</span> <span class="nf">is_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;networkx.classes.graph&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="is_graph_any"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_graph_any">[docs]</a><span class="k">def</span> <span class="nf">is_graph_any</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">or</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">or</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>

<span class="c1">#from python_tools import pandas_utils as pu</span>
<span class="c1">#from python_tools import tqdm_utils as tqu</span>
<span class="c1">#import copy</span>


<div class="viewcode-block" id="subgraph_from_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.subgraph_from_edges">[docs]</a><span class="k">def</span> <span class="nf">subgraph_from_edges</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edge_list</span><span class="p">,</span>
    <span class="n">ref_back</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a networkx graph that is a subgraph of G</span>
<span class="sd">    defined by the list of edges in edge_list.        </span>

<span class="sd">    Requires G to be a networkx Graph or DiGraph</span>
<span class="sd">    edge_list is a list of edges in either (u,v) or (u,v,d) form</span>
<span class="sd">    where u and v are nodes comprising an edge, </span>
<span class="sd">    and d would be a dictionary of edge attributes</span>

<span class="sd">    ref_back determines whether the created subgraph refers to back</span>
<span class="sd">    to the original graph and therefore changes to the subgraph&#39;s </span>
<span class="sd">    attributes also affect the original graph, or if it is to create a</span>
<span class="sd">    new copy of the original graph. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sub_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">edge_list</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]})</span>
    <span class="n">edge_list_no_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_list_no_data</span><span class="p">])</span>

    <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">sub_nodes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_back</span><span class="p">:</span>
        <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G_sub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="n">edges_to_remove</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">sub_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_to_remove</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_list_no_data</span><span class="p">:</span>
            <span class="n">G_sub</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_sub</span></div>

<div class="viewcode-block" id="query_to_subgraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.query_to_subgraph">[docs]</a><span class="k">def</span> <span class="nf">query_to_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edge_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">make_bidirectional_query</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">node_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">delete_edges_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">new_subgraph_from_edges_method</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">optimized_edge_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">delete_edges_in_query</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">edge_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To restrict a graph by </span>
<span class="sd">    a query that is meant to restrict the edges</span>
<span class="sd">    of a graph and return the resultant graph</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Make the query bidirectional if requested</span>
<span class="sd">    1) Build the edge df</span>
<span class="sd">    2) Query the dataframe</span>
<span class="sd">    3) if a node query is given then:</span>
<span class="sd">    - apply node query</span>
<span class="sd">    4) return the dataframe if requested</span>
<span class="sd">    5) Export the edges</span>
<span class="sd">    6) Make an edge induced subgraph</span>
<span class="sd">    </span>
<span class="sd">    # #Example 1: testing basic query</span>
<span class="sd">    G = query_to_subgraph(G1,&quot;u &lt; 2&quot;,</span>
<span class="sd">                      verbose = True,</span>
<span class="sd">                      return_df = False,</span>
<span class="sd">                          node_query=&quot;u &lt; 2&quot;,)</span>

<span class="sd">    nx.draw(G,with_labels=True)</span>

<span class="sd">    #example 2: testing attributes query</span>
<span class="sd">    G = query_to_subgraph(G1,</span>
<span class="sd">                         &quot;(weight&lt;40) or (u&gt;=5)&quot;,</span>
<span class="sd">                         make_bidirectional_query=True,</span>
<span class="sd">                         verbose = True)</span>

<span class="sd">    nx.draw(G,with_labels=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_off_tqdm</span><span class="p">()</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#1) Build the edge df</span>
    <span class="k">if</span> <span class="n">edge_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">optimized_edge_df</span><span class="p">:</span>
            <span class="n">edge_df</span>  <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_df_optimized</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">upstream_name</span><span class="p">,</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">downstream_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Done with edge_df: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1">#2) Query the dataframe</span>
    <span class="k">if</span> <span class="n">edge_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delete_edges_in_query</span><span class="p">:</span>
            <span class="n">edge_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;not (</span><span class="si">{</span><span class="n">edge_query</span><span class="si">}</span><span class="s2">)&quot;</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Performing Edge Query&quot;</span><span class="p">)</span>
            
        <span class="c1">#0) Make the query bidirectional if requested</span>
        <span class="k">if</span> <span class="n">make_bidirectional_query</span><span class="p">:</span>
            <span class="n">edge_query</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">query_bidirectional</span><span class="p">(</span><span class="n">edge_query</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After bidiretional the edge query = </span><span class="si">{</span><span class="n">edge_query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
        <span class="c1">#edge_df_filt = edge_df.query(edge_query)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">edge_df_filt</span> <span class="o">=</span> <span class="n">edge_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">edge_query</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">edge_df_filt</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">edge_df</span><span class="p">,</span><span class="n">edge_query</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_df_filt</span> <span class="o">=</span> <span class="n">edge_df</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After edge filter, # of rows = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_df_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="c1">#3) if a node query is given then:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    6/30 updates:</span>
<span class="sd">    1) get the node df from the graph</span>
<span class="sd">    2) Apply the query to the node df</span>
<span class="sd">    3) pull down all of the node ids</span>
<span class="sd">    4) restrict the edge graph to only those ids</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
        <span class="c1">#nodes_remaining = node_df.query(node_query)[upstream_name].to_list()</span>
        <span class="n">nodes_remaining</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span><span class="n">node_query</span><span class="p">)[</span><span class="n">upstream_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">node_id_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">upstream_name</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">nodes_remaining</span><span class="si">}</span><span class="s2">&quot;</span>
        
        <span class="n">node_query_bi</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">query_bidirectional</span><span class="p">(</span><span class="n">node_id_query</span><span class="p">,</span>
                                              <span class="n">logical_combination</span> <span class="o">=</span> <span class="s2">&quot;and&quot;</span><span class="p">)</span>
        
        <span class="c1">#edge_df_filt = edge_df_filt.query(node_query_bi)</span>
        <span class="n">edge_df_filt</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">edge_df_filt</span><span class="p">,</span><span class="n">node_query_bi</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After bidiretional the node query = </span><span class="si">{</span><span class="n">node_query_bi</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After node filter, # of rows = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_df_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="c1">#4) return the dataframe if requested</span>
    <span class="k">if</span> <span class="n">return_df</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edge_df_filt</span>
    
    <span class="c1">#5) Export the edges</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exporting the edges&quot;</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">df_to_list</span><span class="p">(</span><span class="n">edge_df_filt</span><span class="p">[[</span><span class="n">xu</span><span class="o">.</span><span class="n">upstream_name</span><span class="p">,</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_name</span><span class="p">]],</span>
                         <span class="n">return_tuples</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_edges</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edges</span>
    
    <span class="k">if</span> <span class="n">delete_edges_only</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">new_subgraph_from_edges_method</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">subgraph_from_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">ref_back</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleteing edges only&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
<span class="c1">#             total_edges = xu.edges(G)</span>
<span class="c1">#             removed_edges = nu.setdiff2d(total_edges,edges)</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;    About to copy graph&quot;)</span>
<span class="c1">#             G = copy.deepcopy(G)</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;    About to remove edges&quot;)</span>
<span class="c1">#             G.remove_edges_from(removed_edges)</span>
            <span class="k">return</span> <span class="n">G</span>
    
    <span class="c1">#6) Export the edge induced subgraph</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="subgraph_from_edge_query"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.subgraph_from_edge_query">[docs]</a><span class="k">def</span> <span class="nf">subgraph_from_edge_query</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">query</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">query_to_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                      <span class="n">edge_query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
                      <span class="n">new_subgraph_from_edges_method</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="complete_graph_from_node_ids"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.complete_graph_from_node_ids">[docs]</a><span class="k">def</span> <span class="nf">complete_graph_from_node_ids</span><span class="p">(</span><span class="n">node_ids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Creates a fully connected network from a list of node ids</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = complete_graph_from_node_ids([10,12,13,20])</span>
<span class="sd">    G.edges()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span></div>

<div class="viewcode-block" id="edge_attribute_dict_from_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_attribute_dict_from_node">[docs]</a><span class="k">def</span> <span class="nf">edge_attribute_dict_from_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">])</span></div>

<div class="viewcode-block" id="set_edge_attribute_defualt"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_edge_attribute_defualt">[docs]</a><span class="k">def</span> <span class="nf">set_edge_attribute_defualt</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span>
                              <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span></div>
                        
<div class="viewcode-block" id="filter_down_edge_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.filter_down_edge_attributes">[docs]</a><span class="k">def</span> <span class="nf">filter_down_edge_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">attributes_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
            <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attributes_to_delete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes_to_delete</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
                            <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                            
                <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">attr_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                        <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                        <span class="n">attributes</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attr_to_remove</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
                            <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">attributes_to_delete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes_to_delete</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
                                <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">attr_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                            <span class="n">attributes</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attr_to_remove</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
                                <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
                
                
<span class="c1">#             else:</span>
<span class="c1">#                 for idx in dict(G[u][v]).keys():</span>
<span class="c1">#                     if attribute_name not in G[u][v][idx]:</span>
<span class="c1">#                         G[u][v][idx][attribute_name] = default_value</span>
    
                
    <span class="k">return</span> <span class="n">G</span></div>
                        
<div class="viewcode-block" id="derived_edge_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.derived_edge_attribute">[docs]</a><span class="k">def</span> <span class="nf">derived_edge_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">new_attribute</span><span class="p">,</span>
    <span class="n">edge_function</span><span class="p">,</span>
    <span class="n">delete_original</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">attribute</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">new_attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_function</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">attribute</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">delete_original</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">]:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">new_attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_function</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">delete_original</span><span class="p">:</span>
                            <span class="k">del</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span></div>
                
<div class="viewcode-block" id="combine_edge_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.combine_edge_attributes">[docs]</a><span class="k">def</span> <span class="nf">combine_edge_attributes</span><span class="p">(</span><span class="n">edge_attribute_dicts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To combine dictionaries that </span>
<span class="sd">    store values in [edge1][edge2] = [value]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">super_dict</span> <span class="o">=</span> <span class="n">edge_attribute_dicts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edge_attribute_dicts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">super_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">super_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">super_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">super_dict</span></div>
                

<div class="viewcode-block" id="apply_edge_attribute_dict_to_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.apply_edge_attribute_dict_to_graph">[docs]</a><span class="k">def</span> <span class="nf">apply_edge_attribute_dict_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">edge_attribute_dict</span><span class="p">,</span>
                                      <span class="n">no_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    G = nx.from_edgelist([[1,2],[3,4],[2,3],[2,5]])</span>
<span class="sd">    nx.draw(G,with_labels=True)</span>
<span class="sd">    my_dict = {1:{2:5},2:{3:7,5:10}}</span>
<span class="sd">    xu.apply_edge_attribute_dict_to_graph(G,my_dict,no_overwrite=False,</span>
<span class="sd">                                         label=&quot;weight&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">u_data</span> <span class="ow">in</span> <span class="n">edge_attribute_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">v_data</span> <span class="ow">in</span> <span class="n">u_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">v_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span><span class="n">v_data</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">no_overwrite</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">g</span> <span class="ow">in</span> <span class="n">v_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping key </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> for edge </span><span class="si">{</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2"> because already existed with value </span><span class="si">{</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">v_data</span><span class="p">)</span></div>
                
<div class="viewcode-block" id="edge_attribute_dict_from_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_attribute_dict_from_edges">[docs]</a><span class="k">def</span> <span class="nf">edge_attribute_dict_from_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span>
                                    <span class="n">value_to_store</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_to_store</span>
            
    <span class="k">return</span> <span class="n">return_dict</span></div>
    
<div class="viewcode-block" id="nodes_with_parent_branching"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_with_parent_branching">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_parent_branching</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">n_siblings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">node_names</span><span class="p">[</span><span class="n">n_siblings</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="nodes_with_parent_non_branching"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_with_parent_non_branching">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_parent_non_branching</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">n_siblings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_sibling_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">node_names</span><span class="p">[</span><span class="n">n_siblings</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span></div>


<span class="c1"># ------- 7/17: Helps with the axon finder ---------</span>
<div class="viewcode-block" id="starting_node_from_DiG"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.starting_node_from_DiG">[docs]</a><span class="k">def</span> <span class="nf">starting_node_from_DiG</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the nodes in a graph</span>
<span class="sd">    with no upstream nodes</span>

<span class="sd">    Application: To potentially find</span>
<span class="sd">    the starting node</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">upstream_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upstream_array</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">return_single</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="n">argnan_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">argnan</span><span class="p">(</span><span class="n">upstream_array</span><span class="p">)</span>
    <span class="n">st_node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">argnan_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;st_node = </span><span class="si">{</span><span class="n">st_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">st_node</span></div>

<span class="c1">#def most_upstream_node(G,verbose = False):</span>
    

<div class="viewcode-block" id="shortest_path"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path">[docs]</a><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">catch_error</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Wrapper for the networkx shortest path</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="G_from_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.G_from_edges">[docs]</a><span class="k">def</span> <span class="nf">G_from_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;DiGraph&quot;</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)()</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="downstream_conn_comps"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.downstream_conn_comps">[docs]</a><span class="k">def</span> <span class="nf">downstream_conn_comps</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                         <span class="n">nodes</span><span class="p">,</span>
                         <span class="n">start_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">return_upstream_node_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To group branches into those that </span>
<span class="sd">    are connected to the same upstream node in the possible lists</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Creat e a list to hold all of the possible edges of a graph</span>
<span class="sd">    For each node: </span>
<span class="sd">    1) Calculate the shortest path from each branch to the starting node</span>
<span class="sd">    2) If any of the other branches are on the list then add an edge from </span>
<span class="sd">    that branch to the current branch</span>

<span class="sd">    3) Create a directed graph from the edges</span>
<span class="sd">    4) Divide the directed graph into connected components</span>

<span class="sd">    For each connected component</span>
<span class="sd">    5) Find the most upstream node and add to a dictionary the </span>
<span class="sd">    upstream node --&gt; group of whole connected components</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.downstream_conn_comps(G = limb_obj.concept_network_directional,</span>
<span class="sd">    nodes = [317, 338, 341, 342, 365, 389, 393, 438],</span>
<span class="sd">    start_node = limb_obj.current_starting_node,#limb_obj.current_starting_node</span>
<span class="sd">    verbose = False</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">start_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">starting_node_from_DiG</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1">#0) Creat e a list to hold all of the possible edges of a graph</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_node</span><span class="p">,</span><span class="n">n</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nodes_on_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">shortest_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, branches on shortest path = </span><span class="si">{</span><span class="n">nodes_on_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">edge_list</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes_on_path</span><span class="p">]</span>

    <span class="c1">#3) Create a directed graph from the edges</span>
    <span class="n">G_conn</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">G_from_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G_conn</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of conn_comp = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">return_upstream_node_dict</span><span class="p">:</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
            <span class="n">G_curr</span> <span class="o">=</span> <span class="n">G_conn</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">curr_st_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">starting_node_from_DiG</span><span class="p">(</span><span class="n">G_curr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Conn Comp </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: start_node = </span><span class="si">{</span><span class="n">curr_st_node</span><span class="si">}</span><span class="s2">, conn comp = </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_st_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">return</span> <span class="n">return_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">conn_comp</span></div>
    
    
<span class="c1">#import itertools</span>
<span class="c1">#import time</span>
<div class="viewcode-block" id="all_connected_subgraphs"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_connected_subgraphs">[docs]</a><span class="k">def</span> <span class="nf">all_connected_subgraphs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">start_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_subgraphs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Getting allthe connected subgraphs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
    <span class="n">all_connected_subgraphs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_node = </span><span class="si">{</span><span class="n">start_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># here we ask for all connected subgraphs that have at least 2 nodes AND have less nodes than the input graph</span>
    <span class="k">for</span> <span class="n">nb_nodes</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">SG</span> <span class="ow">in</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">selected_nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">selected_nodes</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nb_nodes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">SG</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">start_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">start_node</span> <span class="ow">in</span> <span class="n">SG</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">print_subgraphs</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">SG</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">all_connected_subgraphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SG</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                
                
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of subgraphs = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_connected_subgraphs</span><span class="p">)</span><span class="si">}</span><span class="s2"> (time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_connected_subgraphs</span></div>

<div class="viewcode-block" id="connected_component_with_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.connected_component_with_node">[docs]</a><span class="k">def</span> <span class="nf">connected_component_with_node</span><span class="p">(</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">connected_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">G</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_only_one</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the connected</span>
<span class="sd">    component with a certain node id</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the connected components if given a graph</span>
<span class="sd">    2) Iterate through the connected components and </span>
<span class="sd">    check if the desired node is in the conn comp (if yes then save off)</span>
<span class="sd">    3) If required, check that only one connected component</span>
<span class="sd">    4) Return winning conn comps</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.connected_component_with_node(3,connected_components= [[1,2,3,4],[5,6]],</span>
<span class="sd">                             verbose=True)</span>
<span class="sd">    &gt;&gt; winning_conn = [[1, 2, 3, 4]]</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">connected_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">connected_components</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">winning_conn</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">connected_components</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_conn = </span><span class="si">{</span><span class="n">winning_conn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_only_one</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">winning_conn</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not one winning component with node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">winning_conn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">winning_conn</span> <span class="o">=</span> <span class="n">winning_conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    

    <span class="k">return</span> <span class="n">winning_conn</span></div>

<div class="viewcode-block" id="most_upstream_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.most_upstream_node">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the most</span>
<span class="sd">    upstream node of a group of nodes in </span>
<span class="sd">    a directional graph</span>
<span class="sd">    assuming that there is one most </span>
<span class="sd">    upstream node</span>

<span class="sd">    Psuedoode: </span>
<span class="sd">    1) Find the node with the most downstream nodes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.most_upstream_node( G = neuron_obj[6].concept_network_directional,</span>
<span class="sd">    nodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],</span>
<span class="sd">                   verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">down_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of downstream for each node = </span><span class="si">{</span><span class="n">down_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">down_count</span><span class="p">)]</span></div>

<div class="viewcode-block" id="least_downstream_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.least_downstream_node">[docs]</a><span class="k">def</span> <span class="nf">least_downstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the most</span>
<span class="sd">    upstream node of a group of nodes in </span>
<span class="sd">    a directional graph</span>
<span class="sd">    assuming that there is one most </span>
<span class="sd">    upstream node</span>

<span class="sd">    Psuedoode: </span>
<span class="sd">    1) Find the node with the most downstream nodes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.most_upstream_node( G = neuron_obj[6].concept_network_directional,</span>
<span class="sd">    nodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],</span>
<span class="sd">                   verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">down_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">n_all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of downstream for each node = </span><span class="si">{</span><span class="n">down_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">down_count</span><span class="p">)]</span></div>

<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="check_downstream_nodes_on_same_path"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.check_downstream_nodes_on_same_path">[docs]</a><span class="k">def</span> <span class="nf">check_downstream_nodes_on_same_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">start_node</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine if downstream</span>
<span class="sd">    nodes are all along the same path</span>
<span class="sd">    to a starting node or not</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the shortest path for each to the start node</span>
<span class="sd">    2) Do a union of all of the paths</span>
<span class="sd">    3) if the union is greater than the size of longest path</span>
<span class="sd">    --&gt; then false</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.check_downstream_nodes_on_same_path(G = limb_obj.concept_network_directional,</span>
<span class="sd">    nodes = [25,26,23,21,27],</span>
<span class="sd">    start_node = 24 )</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">shortest_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_node</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="n">shortest_paths_len</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shortest_paths</span><span class="p">]</span>
    <span class="n">union_path</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">union1d_multi_list</span><span class="p">(</span><span class="n">shortest_paths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_paths_len= </span><span class="si">{</span><span class="n">shortest_paths_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(union_path) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">union_path</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">union_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shortest_paths_len</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="copy_G_without_data"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.copy_G_without_data">[docs]</a><span class="k">def</span> <span class="nf">copy_G_without_data</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">new_G</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)()</span>
    <span class="n">new_G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">new_G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">new_G</span></div>

<span class="n">nodes_edges_only_G</span> <span class="o">=</span> <span class="n">copy_G_without_data</span>

<div class="viewcode-block" id="subgraph_within_radius"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.subgraph_within_radius">[docs]</a><span class="k">def</span> <span class="nf">subgraph_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span><span class="n">plot_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the subgraph surrounding a certain</span>
<span class="sd">    node that are a radius distance away</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = nx.Graph()</span>
<span class="sd">    G.add_weighted_edges_from([[1,2,5],[2,3,10],[3,4,6],[2,5,3]])</span>
<span class="sd">    #nx.draw(G,with_labels = True)</span>

<span class="sd">    xu.subgraph_within_radius(G,3,6,plot_subgraph=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G_loc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">generators</span><span class="o">.</span><span class="n">ego_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_subgraph</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G_loc</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_loc</span></div>

<div class="viewcode-block" id="nodes_within_radius"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_within_radius">[docs]</a><span class="k">def</span> <span class="nf">nodes_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the nodes that </span>
<span class="sd">    are within a certain radius of a node in a</span>
<span class="sd">    graph</span>
<span class="sd">    </span>
<span class="sd">    Ex: (works with digraph but only in direction of arrows is allowed, </span>
<span class="sd">        backwards radius not work)</span>
<span class="sd">    G = nx.Graph()</span>
<span class="sd">    G.add_weighted_edges_from([[1,2,5],[2,3,10],[3,4,6],[2,5,3]])</span>
<span class="sd">    #nx.draw(G,with_labels = True)</span>

<span class="sd">    xu.nodes_within_radius(G,3,6,plot_subgraph=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G_neighbor</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">subgraph_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                           <span class="n">node</span><span class="p">,</span>
                                           <span class="n">radius</span><span class="p">,</span>
                                           <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">G_neighbor</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span></div>

<span class="c1">#import copy</span>
<div class="viewcode-block" id="expand_edges_to_nodes_within_radius"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.expand_edges_to_nodes_within_radius">[docs]</a><span class="k">def</span> <span class="nf">expand_edges_to_nodes_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                                        <span class="n">copy_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">plot_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will add edges between those nodes</span>
<span class="sd">    that are within a radius distance of eachother</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each node in the graph</span>
<span class="sd">    1) Find the nodes within a certain radius</span>
<span class="sd">    2) add edges from node to neighbor nodes to the graph</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = nx.DiGraph()</span>
<span class="sd">    G.add_weighted_edges_from([[1,2,5],[2,3,10],[3,4,6],[2,5,3]])</span>
<span class="sd">    G_new = xu.expand_edges_to_nodes_within_radius(G,radius = 20,plot_graph=True,verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy_graph</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of edges at beginning of expanding edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">neighb</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                       <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has neighbors </span><span class="si">{</span><span class="n">neighb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighb</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of edges at END of expanding edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
    <span class="k">if</span> <span class="n">plot_graph</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting graph after new edges added&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="nodes_on_all_pairwise_paths_betweeen_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_on_all_pairwise_paths_betweeen_nodes">[docs]</a><span class="k">def</span> <span class="nf">nodes_on_all_pairwise_paths_betweeen_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all nodes that exist on pairwise</span>
<span class="sd">    paths between nodes in a group</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Create a list with the nodes requested (final node)</span>
<span class="sd">    For each node</span>
<span class="sd">       Iterate through all other nodes</span>
<span class="sd">           find the shortest path between nodes</span>
<span class="sd">           Add to the final nodes if shortest path exists</span>
<span class="sd">           </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = nx.from_edgelist([[1,2],[2,3],[3,4],[2,5]])</span>
<span class="sd">    xu.nodes_on_all_pairwise_paths_betweeen_nodes(G,[1,4,5,3])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">final_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">final_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span>  <span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="o">!=</span> <span class="n">n1</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">shortest_path</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="n">final_nodes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">final_nodes</span><span class="p">,</span><span class="n">shortest_path</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">final_nodes</span></div>

<div class="viewcode-block" id="local_radius_conn_comps"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.local_radius_conn_comps">[docs]</a><span class="k">def</span> <span class="nf">local_radius_conn_comps</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span>
                            <span class="n">add_nodes_on_paths_inside_connected_components</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_upstream_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will group together nodes in the </span>
<span class="sd">    list provided that are within a certain</span>
<span class="sd">    radius distance from each other </span>
<span class="sd">    (and optionally add the nodes that are in between paths</span>
<span class="sd">    between nodes in the connected component)</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) expand the edges of the graph with the specified radius</span>
<span class="sd">    2) Take a subgraph of the new expanded graph</span>
<span class="sd">    3) Divided the subgraph into connected components</span>
<span class="sd">    4) If requested, expand the connected components to</span>
<span class="sd">    include nodes that lie on paths between nodes within a connected component</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = nx.DiGraph()</span>
<span class="sd">    G.add_weighted_edges_from([[1,2,5],[2,3,10],[3,4,6],[4,6,12],[6,7,7],[2,5,3]])</span>
<span class="sd">    G_new = xu.local_radius_conn_comps(G,nodes=[1,5,6,7],radius = 7,verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) expand the edges of the graph with the specified radius</span>
    <span class="n">G_exp</span> <span class="o">=</span> <span class="n">expand_edges_to_nodes_within_radius</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">radius</span><span class="p">)</span>
    
    <span class="c1">#2) Take a subgraph of the new expanded graph </span>
    <span class="n">G_exp_sub</span> <span class="o">=</span> <span class="n">G_exp</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    
    <span class="c1">#3) Divided the subgraph into connected components</span>
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G_exp_sub</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp = </span><span class="si">{</span><span class="n">conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">add_nodes_on_paths_inside_connected_components</span><span class="p">:</span>
        
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">nodes_on_all_pairwise_paths_betweeen_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">]</span>
        <span class="c1">#print(f&quot;After add nodes on path, conn_comp = {conn_comp}&quot;)</span>
        
    <span class="k">if</span> <span class="n">return_upstream_dict</span><span class="p">:</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="p">{</span><span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">):</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">}</span>
        
    <span class="k">return</span> <span class="n">conn_comp</span></div>


<div class="viewcode-block" id="expand_nodes_to_all_nodes_on_path_between_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.expand_nodes_to_all_nodes_on_path_between_nodes">[docs]</a><span class="k">def</span> <span class="nf">expand_nodes_to_all_nodes_on_path_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_nodes_on_shortest_paths_between_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_node_attributes_from_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_node_attributes_from_df">[docs]</a><span class="k">def</span> <span class="nf">set_node_attributes_from_df</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">index_name</span><span class="o">=</span><span class="n">node_id_default</span><span class="p">):</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="edge_df_optimized"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_df_optimized">[docs]</a><span class="k">def</span> <span class="nf">edge_df_optimized</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edge_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">source</span><span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span>
    <span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span>
    <span class="n">node_attributes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node_attributes_source_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node_attributes_target_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    edge_key: Returns just the edges </span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    
    
    <span class="n">return_df</span> <span class="o">=</span>  <span class="n">nx</span><span class="o">.</span><span class="n">convert_matrix</span><span class="o">.</span><span class="n">to_pandas_edgelist</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                <span class="n">source</span><span class="o">=</span> <span class="n">source</span><span class="p">,</span>
                                                <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                               <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">node_attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">add_node_attributes_to_edge_df</span><span class="p">(</span>
            <span class="n">return_df</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span> <span class="n">source</span><span class="p">,</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span>
            <span class="n">node_attributes</span> <span class="o">=</span> <span class="n">node_attributes</span><span class="p">,</span>
            <span class="n">node_attributes_source_name</span> <span class="o">=</span> <span class="n">node_attributes_source_name</span><span class="p">,</span>
            <span class="n">node_attributes_target_name</span> <span class="o">=</span> <span class="n">node_attributes_target_name</span><span class="p">,</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,)</span>
        
    <span class="k">return</span> <span class="n">return_df</span></div>

<div class="viewcode-block" id="add_node_attributes_to_edge_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.add_node_attributes_to_edge_df">[docs]</a><span class="k">def</span> <span class="nf">add_node_attributes_to_edge_df</span><span class="p">(</span>
    <span class="n">edge_df</span><span class="p">,</span>
    <span class="n">node_attributes</span><span class="p">,</span>
    <span class="n">source</span><span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span>
    <span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span>
    <span class="n">node_attributes_source_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node_attributes_target_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">node_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">G</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add node attributes to an edge_df already generated</span>
<span class="sd">    </span>
<span class="sd">    xu.add_node_attributes_to_edge_df(</span>
<span class="sd">        edge_df_pre,</span>
<span class="sd">        node_attributes = [&quot;gnn_cell_type&quot;],</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        G = G,</span>
<span class="sd">        node_attributes_source_name = &quot;presyn&quot;,</span>
<span class="sd">        node_attributes_target_name = &quot;postsyn&quot;,</span>
<span class="sd">        #node_df = node_df</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">node_attributes_source_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_attributes_source_name</span> <span class="o">=</span> <span class="n">source</span>
    <span class="k">if</span> <span class="n">node_attributes_target_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_attributes_target_name</span> <span class="o">=</span> <span class="n">target</span>
    
    <span class="n">return_df</span> <span class="o">=</span> <span class="n">edge_df</span>
    
    <span class="k">if</span> <span class="n">node_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_id</span><span class="o">=</span><span class="n">source</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        
    
    <span class="n">node_df</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">[[</span><span class="n">source</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_attributes</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">old_name</span><span class="p">,</span><span class="n">prefix</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">],</span>
                               <span class="p">[</span><span class="n">node_attributes_source_name</span><span class="p">,</span>
                                 <span class="n">node_attributes_target_name</span><span class="p">]):</span>
        <span class="n">rename_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:</span><span class="n">old_name</span><span class="p">}</span>
        <span class="n">rename_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_df</span><span class="o">.</span><span class="n">columns</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">source</span> <span class="ow">and</span> 
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">return_df</span><span class="o">.</span><span class="n">columns</span><span class="p">})</span>
        <span class="n">node_df_curr</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span><span class="n">rename_dict</span><span class="p">)</span>
        <span class="n">return_df</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">return_df</span><span class="p">,</span><span class="n">node_df_curr</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="n">old_name</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_df</span></div>
        
        

<div class="viewcode-block" id="G_from_pandas_edgelist"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.G_from_pandas_edgelist">[docs]</a><span class="k">def</span> <span class="nf">G_from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                           <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span>
                           <span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span>
                           <span class="n">graph_type</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">,</span>
                           <span class="n">edge_attr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will create a graph from a pandas edgelist</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph_type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">graph_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span>
                           <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">,</span>
                           <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span>
                           <span class="n">edge_attr</span> <span class="o">=</span> <span class="n">edge_attr</span><span class="p">,</span>
                           <span class="n">create_using</span> <span class="o">=</span> <span class="n">graph_type</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Graph creation = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="edge_df_from_G"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_df_from_G">[docs]</a><span class="k">def</span> <span class="nf">edge_df_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                   <span class="n">source_name</span><span class="o">=</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span>
                   <span class="n">target_name</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_df_optimized</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                <span class="n">source</span> <span class="o">=</span> <span class="n">source_name</span><span class="p">,</span>
                                <span class="n">target</span> <span class="o">=</span> <span class="n">target_name</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<span class="c1">#import time</span>
<div class="viewcode-block" id="edge_and_node_df"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_and_node_df">[docs]</a><span class="k">def</span> <span class="nf">edge_and_node_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                    <span class="n">edge_df_ids</span><span class="p">,</span>
                    <span class="n">node_df_id</span><span class="o">=</span><span class="n">upstream_name</span><span class="p">,</span>
                     <span class="n">edge_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">node_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">return_node_df</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a dataframe</span>
<span class="sd">    with the edges and the node attributes apended to the edges</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Generate the edge df</span>
<span class="sd">    2) Generate the node df</span>
<span class="sd">    3) merge the node df to the edge df for each fo the edge ids</span>
<span class="sd">    4) Return the dataframe</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    edge_df_ids=[&quot;presyn&quot;,&quot;postsyn&quot;]</span>
<span class="sd">    edge_df = xu.edge_df_from_G(G=G_proof_v6,</span>
<span class="sd">                          source_name = edge_df_ids[0],</span>
<span class="sd">                          target_name = edge_df_ids[1],</span>

<span class="sd">                         )</span>

<span class="sd">    edge_node_df = xu.edge_and_node_df(G_proof_v6,</span>
<span class="sd">                       edge_df_ids=edge_df_ids,</span>
<span class="sd">                       node_df_id=&quot;segment_split_id&quot;,</span>
<span class="sd">                       verbose = True,</span>
<span class="sd">                                      edge_df = edge_df)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">edge_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">e_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_df_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                      <span class="n">source_name</span> <span class="o">=</span> <span class="n">edge_df_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                      <span class="n">target_name</span> <span class="o">=</span> <span class="n">edge_df_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>

                     <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_df</span> <span class="o">=</span> <span class="n">edge_df</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1) edge df creation: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">node_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                          <span class="n">node_id</span><span class="o">=</span><span class="n">node_df_id</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2) node df creation: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>



    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">edge_df_ids</span><span class="p">:</span>
        <span class="n">node_df_renamed</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">add_prefix_to_columns</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">)</span>
        <span class="n">node_df_renamed_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">node_df_id</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">e_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">e_df</span><span class="p">,</span>
                 <span class="n">node_df_renamed</span><span class="p">,</span>
                 <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                 <span class="n">left_on</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                 <span class="n">right_on</span><span class="o">=</span><span class="n">node_df_renamed_id</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">e_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">e_df</span><span class="p">,[</span><span class="n">node_df_renamed_id</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;3) Total time for merges: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_node_df</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e_df</span><span class="p">,</span><span class="n">node_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e_df</span></div>

<div class="viewcode-block" id="print_node_edges_counts"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.print_node_edges_counts">[docs]</a><span class="k">def</span> <span class="nf">print_node_edges_counts</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">G_prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">G_prefix</span><span class="si">}</span><span class="s2"> Graph: # of nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">, # of edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    




    
<div class="viewcode-block" id="closest_k_leaf_neighbors_in_binary_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.closest_k_leaf_neighbors_in_binary_tree">[docs]</a><span class="k">def</span> <span class="nf">closest_k_leaf_neighbors_in_binary_tree</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">k</span><span class="p">,</span>
    <span class="n">return_exactly_k</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the k closest leaf nodes in a binary</span>
<span class="sd">    tree by traversing the upstream nodes and finding all downstream nodes</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    while number of neighbors is less than min</span>
<span class="sd">    1) Get the upstream node of the current node</span>
<span class="sd">    2) Get all the downstream nodes</span>
<span class="sd">    3) Add only the leaf nodes as neighbors</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_node = </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">node</span>
    <span class="n">neighbor_leaves</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">leave_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_out_degree_k</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbor_leaves</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">counter</span><span class="o">+=</span> <span class="mi">1</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>
        <span class="n">neighbor_leaves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">),</span><span class="n">leave_nodes</span><span class="p">)</span>
        <span class="n">neighbor_leaves</span> <span class="o">=</span> <span class="n">neighbor_leaves</span><span class="p">[</span><span class="n">neighbor_leaves</span><span class="o">!=</span> <span class="n">node</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;On iteration </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbor_leaves</span><span class="p">)</span><span class="si">}</span><span class="s2"> downstream_leaves: </span><span class="si">{</span><span class="n">neighbor_leaves</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbor_leaves</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">break</span>
            
        <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="n">max_iterations</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Reached max iterations&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">return_exactly_k</span><span class="p">:</span>
        <span class="n">neighbor_leaves</span> <span class="o">=</span> <span class="n">neighbor_leaves</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">neighbor_leaves</span></div>
    
       
<div class="viewcode-block" id="remove_nodes_from"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_nodes_from">[docs]</a><span class="k">def</span> <span class="nf">remove_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
       
    

<div class="viewcode-block" id="all_paths_to_leaf_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_paths_to_leaf_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_paths_to_leaf_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">start_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To find all of the list of branch paths to leaf nodes on </span>
<span class="sd">    limb</span>

<span class="sd">    1) Get all of the leaf nodes</span>
<span class="sd">    2) Get all paths from starting node to leaf nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">leaf_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">leaf_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leaf_nodes= </span><span class="si">{</span><span class="n">leaf_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start node = </span><span class="si">{</span><span class="n">start_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">all_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_node</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">leaf_nodes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_paths</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">all_paths</span></div>

<span class="c1">#import networkx as nx</span>
<div class="viewcode-block" id="remove_edge_reattach_children_di"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_edge_reattach_children_di">[docs]</a><span class="k">def</span> <span class="nf">remove_edge_reattach_children_di</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove a node and reattach any children to the parents</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the parent of the node</span>
<span class="sd">    2) Get the children of the node</span>
<span class="sd">    3) Remove the node</span>
<span class="sd">    4) Create edges from the parent to the children</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    </span>
<span class="sd">    import networkx as nx</span>
<span class="sd">    import matplotlib.pyplot as plt</span>
<span class="sd">    G1 = nx.DiGraph()</span>
<span class="sd">    G1.add_edges_from([[1,2],[2,3],[2,4]])</span>
<span class="sd">    print(f&quot;Before&quot;)</span>
<span class="sd">    nx.draw(G1,with_labels = True)</span>
<span class="sd">    plt.show()</span>
<span class="sd">    G1_new = remove_edge_reattach_children_di(G1,2)</span>
<span class="sd">    print(f&quot;After removal&quot;)</span>
<span class="sd">    nx.draw(G1_new,with_labels = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
    
    <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
    <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">parent</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent = </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2">, children = </span><span class="si">{</span><span class="n">children</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_edges = </span><span class="si">{</span><span class="n">new_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<span class="n">remove_node_reattach_children_di</span> <span class="o">=</span> <span class="n">remove_edge_reattach_children_di</span>

<div class="viewcode-block" id="graph_attr_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_attr_dict">[docs]</a><span class="k">def</span> <span class="nf">graph_attr_dict</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span></div>
<div class="viewcode-block" id="set_graph_attr_with_dict"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_graph_attr_with_dict">[docs]</a><span class="k">def</span> <span class="nf">set_graph_attr_with_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>
<div class="viewcode-block" id="set_graph_attr"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_graph_attr">[docs]</a><span class="k">def</span> <span class="nf">set_graph_attr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="n">xu</span><span class="o">.</span><span class="n">set_graph_attr_with_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span><span class="p">})</span></div>
<div class="viewcode-block" id="get_graph_attr"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_graph_attr">[docs]</a><span class="k">def</span> <span class="nf">get_graph_attr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>
<span class="c1"># ------------ drawing functions --------------</span>
<span class="c1">#import matplotlib.pyplot as plt</span>
<span class="c1">#import pydot</span>
<span class="c1">#from networkx.drawing.nx_pydot import graphviz_layout</span>

<div class="viewcode-block" id="draw_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.draw_tree">[docs]</a><span class="k">def</span> <span class="nf">draw_tree</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">draw_type</span> <span class="o">=</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span><span class="c1">#&quot;twopi&quot; (the circular), &quot;circo&quot; (makes square like)</span>
    <span class="n">node_size</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
    <span class="n">font_size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">font_color</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span><span class="p">,</span>
    <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">),</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To help draw a nice tree graph</span>
<span class="sd">    </span>
<span class="sd">    #https://stackoverflow.com/questions/57512155/how-to-draw-a-tree-more-beautifully-in-networkx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">copy_G_without_data</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;dot&quot;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> 
            <span class="n">pos</span><span class="p">,</span>
            <span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
            <span class="n">font_size</span> <span class="o">=</span> <span class="n">font_size</span><span class="p">,</span>
            <span class="n">font_color</span> <span class="o">=</span> <span class="n">font_color</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    
<span class="k">def</span> <span class="nf">star_graph</span><span class="p">(</span>
    <span class="n">n_vertices</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span>  <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_vertices</span><span class="p">)])</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span>
    
<span class="c1">#from . import numpy_dep as np</span>
<div class="viewcode-block" id="adjacency_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.adjacency_matrix">[docs]</a><span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">dense</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">return_nodelist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">dense</span><span class="p">:</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    
    <span class="k">if</span> <span class="n">return_nodelist</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adj_matrix</span><span class="p">,</span><span class="n">nodelist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adj_matrix</span></div>
    
<div class="viewcode-block" id="modularity_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.modularity_matrix">[docs]</a><span class="k">def</span> <span class="nf">modularity_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">modularity_matrix</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<span class="n">modularity</span> <span class="o">=</span> <span class="n">modularity_matrix</span>

<div class="viewcode-block" id="laplacian"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.laplacian">[docs]</a><span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dense</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodelist</span><span class="o">=</span><span class="n">nodelist</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">dense</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="degree_matrix_from_adj"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.degree_matrix_from_adj">[docs]</a><span class="k">def</span> <span class="nf">degree_matrix_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="laplacian_from_adj"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.laplacian_from_adj">[docs]</a><span class="k">def</span> <span class="nf">laplacian_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">degree_matrix_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="n">array</span></div>

<span class="n">laplacian_matrix</span> <span class="o">=</span> <span class="n">laplacian</span>
    
<div class="viewcode-block" id="G_from_adjacency_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.G_from_adjacency_matrix">[docs]</a><span class="k">def</span> <span class="nf">G_from_adjacency_matrix</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To recover a networkx graph</span>
<span class="sd">    from an adjacency matrix (and add proper node labels)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;sparse&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

    <span class="n">G_rec</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G_rec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1">#print(np.max(list(G_rec.nodes())))</span>
        <span class="c1">#print(f&quot;nodelist = {np.max(nodelist)}&quot;)</span>
        <span class="n">G_rec</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">relabel_node_names</span><span class="p">(</span><span class="n">G_rec</span><span class="p">,{</span><span class="n">i</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)},</span><span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#print(np.max(list(G_rec.nodes())))</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G_rec</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G_rec</span></div>
    
<span class="c1">#import pandas as pd</span>
<div class="viewcode-block" id="feature_matrix_from_G"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.feature_matrix_from_G">[docs]</a><span class="k">def</span> <span class="nf">feature_matrix_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the node features matrix</span>
<span class="sd">    from a list of node features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">([</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">features</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">return_df</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="adjacency_feature_info"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.adjacency_feature_info">[docs]</a><span class="k">def</span> <span class="nf">adjacency_feature_info</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">dense_adjacency</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_df_for_feature_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">feature_matrix_dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process: get the information</span>
<span class="sd">    needed for GNN training</span>
<span class="sd">    1) Node names</span>
<span class="sd">    2) Adjacency matrix</span>
<span class="sd">    3) Feature matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">node_df_features</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="n">adj_matrix</span><span class="p">,</span><span class="n">nodelist</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">dense</span><span class="o">=</span><span class="n">dense_adjacency</span><span class="p">,</span>
        <span class="n">return_nodelist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="n">X</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">feature_matrix_from_G</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">return_df</span><span class="o">=</span><span class="n">return_df_for_feature_matrix</span><span class="p">,</span>
        <span class="n">features</span> <span class="o">=</span><span class="n">features</span><span class="p">,)</span>
    
    <span class="k">if</span> <span class="n">feature_matrix_dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">feature_matrix_dtype</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">nodelist</span> <span class="o">=</span> <span class="n">nodelist</span><span class="p">,</span>
            <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span>
            <span class="n">adjacency</span><span class="o">=</span><span class="n">adj_matrix</span><span class="p">,</span>
            <span class="n">feature_matrix</span> <span class="o">=</span> <span class="n">X</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodelist</span><span class="p">,</span><span class="n">features</span><span class="p">,</span><span class="n">adj_matrix</span><span class="p">,</span><span class="n">X</span></div>
    
    
<span class="c1">#-------- searching functions ----------</span>
<div class="viewcode-block" id="nodes_DFS"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_DFS">[docs]</a><span class="k">def</span> <span class="nf">nodes_DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="p">))</span></div>

<span class="c1">#from python_tools import numpy_utils as nu</span>
<div class="viewcode-block" id="delete_node_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.delete_node_attributes">[docs]</a><span class="k">def</span> <span class="nf">delete_node_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">attributes_not_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">nodelist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">nodelist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodelist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_attrs</span> <span class="o">=</span> <span class="n">attributes</span>
        <span class="c1">#print(f&quot;curr_attrs = {curr_attrs}, attributes = {attributes}&quot;)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">curr_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attributes_not_to_delete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes_not_to_delete</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">a</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t delete </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> from node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="filter_down_node_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.filter_down_node_attributes">[docs]</a><span class="k">def</span> <span class="nf">filter_down_node_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attributes_to_delete</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">delete_node_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attributes</span><span class="o">=</span><span class="n">attributes_to_delete</span><span class="p">,</span>
    <span class="n">attributes_not_to_delete</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
    <span class="n">nodelist</span> <span class="o">=</span> <span class="n">nodelist</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_node_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_node_attribute">[docs]</a><span class="k">def</span> <span class="nf">set_node_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">attribute_value</span><span class="p">,</span>
    <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set a single node</span>
<span class="sd">    attribute (or apply to all the </span>
<span class="sd">    nodes if none given)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    <span class="n">node</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">attribute_value</span><span class="si">}</span><span class="s2"> for nodes: </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">attribute_value</span>
    
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="nodes_with_non_none_attributes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_with_non_none_attributes">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_non_none_attributes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">node_name</span> <span class="o">=</span> <span class="n">node_id_default</span><span class="p">,</span>
    <span class="n">return_attribute_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find out all the nodes with </span>
<span class="sd">    an autoproofreading filter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> == </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes without None value in </span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_attribute_value</span><span class="p">:</span>
        <span class="n">filt_names</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span><span class="n">filt_names</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nodes</span></div>
    
<div class="viewcode-block" id="is_frozen"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_frozen">[docs]</a><span class="k">def</span> <span class="nf">is_frozen</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Usually happens when iterating over nodes (because it is a dictionary)</span>
<span class="sd">    and can&#39;t change a dictionaries size while iterating over it</span>
<span class="sd">    </span>
<span class="sd">    Conclusion: Happens when try to modify the nodes of a subgraph, need to</span>
<span class="sd">    make do G.subgraph([nodes]).copy()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_frozen</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>

<div class="viewcode-block" id="edgelist_from_adjacency_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edgelist_from_adjacency_matrix">[docs]</a><span class="k">def</span> <span class="nf">edgelist_from_adjacency_matrix</span><span class="p">(</span>
    <span class="n">array</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert an adjacency</span>
<span class="sd">    matrix to an edgelist</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Read in the adjacency matrix to a networkx Graph</span>
<span class="sd">    2) export the edges of the Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">G_from_adjacency_matrix</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">edgelist</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of Edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edgelist</span></div>

<div class="viewcode-block" id="is_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_tree">[docs]</a><span class="k">def</span> <span class="nf">is_tree</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>

<div class="viewcode-block" id="high_degree_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.high_degree_nodes">[docs]</a><span class="k">def</span> <span class="nf">high_degree_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n_children_min</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">n_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n_children_min</span> <span class="p">])</span></div>
<div class="viewcode-block" id="binary_tree_from_di_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.binary_tree_from_di_tree">[docs]</a><span class="k">def</span> <span class="nf">binary_tree_from_di_tree</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">child_idx_to_reattach</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert any tree into a binary tree</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the nodes with more than 1 child</span>
<span class="sd">    While the list of non-binary nodes is non empty:</span>
<span class="sd">    a. Get the first node and all of its children</span>
<span class="sd">    b. disconnect parent from all children except first 2</span>
<span class="sd">    c. Reattach disconnected children to first/last child</span>
<span class="sd">    d. Repeat for next node</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">high_degree_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>


    

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---New Loop: high_degree_nodes=</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">high_degree_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">high_degree_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---Working on node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#a. Get the first node and all of its children</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;children = </span><span class="si">{</span><span class="n">children</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">keep_children</span> <span class="o">=</span> <span class="n">children</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">disconnect_children</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

            <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">disconnect_children</span><span class="p">])</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([</span>
                <span class="p">(</span><span class="n">keep_children</span><span class="p">[</span><span class="n">child_idx_to_reattach</span><span class="p">],</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">disconnect_children</span><span class="p">])</span>

        <span class="n">high_degree_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">high_degree_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="c1"># to check everything went well:</span>
    <span class="n">tree_status</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">is_tree</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">),</span><span class="n">return_subgraphs</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
    <span class="k">if</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">tree_status</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">G</span></div>
    

<div class="viewcode-block" id="n_connected_components"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_connected_components">[docs]</a><span class="k">def</span> <span class="nf">n_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span></div>

<div class="viewcode-block" id="get_node_attribute_for_all_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_node_attribute_for_all_nodes">[docs]</a><span class="k">def</span> <span class="nf">get_node_attribute_for_all_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span><span class="n">name</span><span class="p">,</span>
    <span class="n">return_list</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">atts</span> <span class="o">=</span> <span class="n">get_node_attributes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">node_list</span><span class="o">=</span><span class="n">nodes</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_list</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">atts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">atts</span></div>

<div class="viewcode-block" id="set_node_attribute_default"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_node_attribute_default">[docs]</a><span class="k">def</span> <span class="nf">set_node_attribute_default</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">attributes</span><span class="p">,</span> <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">attributes</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span></div>
                
<div class="viewcode-block" id="derived_node_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.derived_node_attribute">[docs]</a><span class="k">def</span> <span class="nf">derived_node_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">new_attribute</span><span class="p">,</span>
    <span class="n">func</span><span class="p">):</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">new_attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">attribute</span><span class="p">])</span></div>
            
<div class="viewcode-block" id="derived_node_attribute_from_func"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.derived_node_attribute_from_func">[docs]</a><span class="k">def</span> <span class="nf">derived_node_attribute_from_func</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span></div>
        
<div class="viewcode-block" id="derived_edge_attribute_from_func"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.derived_edge_attribute_from_func">[docs]</a><span class="k">def</span> <span class="nf">derived_edge_attribute_from_func</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    def comp_flat(key):</span>
<span class="sd">        if key[&quot;postsyn_compartment_fine&quot;] is None:</span>
<span class="sd">            return key[&quot;postsyn_compartment_coarse&quot;]</span>
<span class="sd">        else:</span>
<span class="sd">            return key[&quot;postsyn_compartment_fine&quot;]</span>

<span class="sd">    xu.derived_edge_attribute_from_func(</span>
<span class="sd">        G,</span>
<span class="sd">        &quot;postsyn_compartment_flat&quot;,</span>
<span class="sd">        comp_flat </span>
<span class="sd">        )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>
                
<div class="viewcode-block" id="set_edge_attribute_from_node_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_edge_attribute_from_node_attribute">[docs]</a><span class="k">def</span> <span class="nf">set_edge_attribute_from_node_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_prefix</span> <span class="o">=</span> <span class="n">upstream_name</span><span class="p">,</span>
    <span class="n">downstream_prefix</span> <span class="o">=</span> <span class="n">downstream_name</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Add a certain node property of the presyn and postsyn</span>
<span class="sd">    to the edge properties</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get a lookup of the property you want</span>
<span class="sd">    2) Go through the edges and add it to the edge attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
    <span class="n">multi_flag</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on setting attribute </span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">att_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">att</span><span class="p">,</span><span class="n">default_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">multi_flag</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">upstream_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">downstream_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">att_dict</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span>
                    
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  --&gt; total time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="set_edge_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.set_edge_attribute">[docs]</a><span class="k">def</span> <span class="nf">set_edge_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node_1</span><span class="p">,</span>
    <span class="n">node_2</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">edge_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">edge_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span><span class="p">[</span><span class="n">node_1</span><span class="p">][</span><span class="n">node_2</span><span class="p">][</span><span class="n">edge_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span><span class="p">[</span><span class="n">node_1</span><span class="p">][</span><span class="n">node_2</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>
        
<div class="viewcode-block" id="get_edge_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.get_edge_attribute">[docs]</a><span class="k">def</span> <span class="nf">get_edge_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node_1</span><span class="p">,</span>
    <span class="n">node_2</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">edge_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">edge_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">[</span><span class="n">node_1</span><span class="p">][</span><span class="n">node_2</span><span class="p">][</span><span class="n">edge_idx</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="p">[</span><span class="n">node_1</span><span class="p">][</span><span class="n">node_2</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span></div>
    
<span class="c1">#import networkx as nx</span>
<div class="viewcode-block" id="convert_to_non_multi"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.convert_to_non_multi">[docs]</a><span class="k">def</span> <span class="nf">convert_to_non_multi</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_digraph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span></div>
    
    
<div class="viewcode-block" id="is_isomorphic"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.is_isomorphic">[docs]</a><span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">G2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span><span class="n">G2</span><span class="p">)</span></div>

<div class="viewcode-block" id="edge_str_from_G"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_str_from_G">[docs]</a><span class="k">def</span> <span class="nf">edge_str_from_G</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">delimiter</span> <span class="o">=</span> <span class="s2">&quot;;&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">delimiter</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span><span class="n">e2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span> <span class="o">+</span> <span class="n">delimiter</span></div>

<span class="c1">#from python_tools import string_utils as stru</span>
<div class="viewcode-block" id="motif_Gs_for_n_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.motif_Gs_for_n_nodes">[docs]</a><span class="k">def</span> <span class="nf">motif_Gs_for_n_nodes</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;DiGraph&quot;</span><span class="p">,</span>
    <span class="n">enforce_n_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute all possible combinations</span>
<span class="sd">    of edges in n nodes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all combinations of edges</span>

<span class="sd">    For each connection: </span>
<span class="sd">    a) Build a graph of it</span>
<span class="sd">    b) See if the graph matches the dotmotif of another unique graph</span>
<span class="sd">    c) If it doesn then add it to the unique list (and register the number of nodes associated)</span>

<span class="sd">    2) Filter for a certain amount of nodes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from python_tools import networkx_utils as xu</span>
<span class="sd">    xu.motif_Gs_for_n_nodes(n=3,plot = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">stru</span><span class="o">.</span><span class="n">number_to_letter</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_names = </span><span class="si">{</span><span class="n">node_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;Di&quot;</span> <span class="ow">in</span> <span class="n">graph_type</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">choose_k_permutations</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">choose_k_combinations</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="n">binary_mat</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">binary_permutation_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of edges = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">binary_mat</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique combinations&quot;</span><span class="p">)</span>


    <span class="n">unique_G</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e_idx</span> <span class="ow">in</span> <span class="n">binary_mat</span><span class="p">:</span>
        <span class="n">curr_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on edges = </span><span class="si">{</span><span class="n">curr_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#a) Build a graph of it</span>
        <span class="n">G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">curr_edges</span><span class="p">)</span>

        <span class="c1">#b) See if the graph matches the dotmotif of another unique graph</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">curr_G</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_G</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
                <span class="k">continue</span>

            <span class="n">iso_match</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">curr_G</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">iso_match</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found matching graph: </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span> 
            <span class="n">unique_G</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unique number of Graphs for </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> nodes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">enforce_n_nodes</span><span class="p">:</span>
        <span class="n">unique_G</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_G</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After filtering to </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> node graphs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_G</span></div>
    
    
<div class="viewcode-block" id="motif_strs_for_n_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.motif_strs_for_n_nodes">[docs]</a><span class="k">def</span> <span class="nf">motif_strs_for_n_nodes</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">motif_Gs</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">motif_Gs_for_n_nodes</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">edge_str_from_G</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">motif_Gs</span><span class="p">]</span></div>

<div class="viewcode-block" id="compute_node_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.compute_node_attribute">[docs]</a><span class="k">def</span> <span class="nf">compute_node_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">attribute_function</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">attribute_function</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span></div>
        
        
<span class="c1">#import networkx.classes.function as cls_func</span>
<div class="viewcode-block" id="path_distance"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.path_distance">[docs]</a><span class="k">def</span> <span class="nf">path_distance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cls_func</span><span class="o">.</span><span class="n">path_weight</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>
    
    
<span class="c1"># -------- for different graph constructors ----</span>
<div class="viewcode-block" id="path_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.path_graph">[docs]</a><span class="k">def</span> <span class="nf">path_graph</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<span class="n">line_graph</span> <span class="o">=</span> <span class="n">path_graph</span>

<div class="viewcode-block" id="complete_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.complete_graph">[docs]</a><span class="k">def</span> <span class="nf">complete_graph</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="cycle_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.cycle_graph">[docs]</a><span class="k">def</span> <span class="nf">cycle_graph</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>
<span class="n">circle_graph</span> <span class="o">=</span> <span class="n">cycle_graph</span>

<div class="viewcode-block" id="balanced_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.balanced_tree">[docs]</a><span class="k">def</span> <span class="nf">balanced_tree</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># compute the number of splits needed</span>
    <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">log_n</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">degree</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">balanced_tree</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span><span class="n">height</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="binary_tree"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.binary_tree">[docs]</a><span class="k">def</span> <span class="nf">binary_tree</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">balanced_tree</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="star_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.star_graph">[docs]</a><span class="k">def</span> <span class="nf">star_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="self_loop_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.self_loop_edges">[docs]</a><span class="k">def</span> <span class="nf">self_loop_edges</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create self loops </span>
<span class="sd">    from tne number of nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">edges</span></div>
    
<div class="viewcode-block" id="edge_list_from_graph_type"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_list_from_graph_type">[docs]</a><span class="k">def</span> <span class="nf">edge_list_from_graph_type</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">graph_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">graph_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">add_self_loops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">bidirectional</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate an edgelist for a</span>
<span class="sd">    given graph type and size</span>
<span class="sd">    </span>
<span class="sd">    --- Example ---</span>
<span class="sd">    n = 10</span>
<span class="sd">    graph_type = &quot;complete_graph&quot;</span>

<span class="sd">    xu.edge_list_from_graph_type(</span>
<span class="sd">        n=n,</span>
<span class="sd">        graph_type=graph_type,</span>
<span class="sd">        plot=True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">return_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
    
    <span class="k">if</span> <span class="n">bidirectional</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">return_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">return_edges</span><span class="p">,</span><span class="n">return_edges</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]])</span>
    
    
    <span class="k">if</span> <span class="n">add_self_loops</span><span class="p">:</span>
        <span class="n">return_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">return_edges</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">xu</span><span class="o">.</span><span class="n">self_loop_edges</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">return_edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="shortest_path_length"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_length">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_length</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span> 
    <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dijkstra&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span>
        <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> 
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> 
        <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> 
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="subgraph_downstream_of_node"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.subgraph_downstream_of_node">[docs]</a><span class="k">def</span> <span class="nf">subgraph_downstream_of_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span>
                 <span class="n">G</span><span class="p">,</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">include_self</span><span class="o">=</span><span class="n">include_self</span>
            <span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="all_downstream_nodes_including_self"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_downstream_nodes_including_self">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_nodes_including_self</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span>
                 <span class="n">G</span><span class="p">,</span>
                <span class="n">node</span><span class="p">,</span>
                <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span></div>

<span class="c1">#from python_tools.tqdm_utils import tqdm</span>
<div class="viewcode-block" id="compute_edge_statistic"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.compute_edge_statistic">[docs]</a><span class="k">def</span> <span class="nf">compute_edge_statistic</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edge_func</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_loop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">node1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
        <span class="k">for</span> <span class="n">node2</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">node1</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">edge_func</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span>
                <span class="n">node1</span><span class="p">,</span>
                <span class="n">node2</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose_loop</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for adding </span><span class="si">{</span><span class="n">edge_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="edge_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_graph">[docs]</a><span class="k">def</span> <span class="nf">edge_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">plot_node_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_edge_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Converts a graph into a graph</span>
<span class="sd">    where the edges are now the nodes and </span>
<span class="sd">    edges between the nodes are if the </span>
<span class="sd">    edges are incident on the same node</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G_test = nx.from_edgelist([(1,2),(2,3),(2,4),(3,5),(3,6)])</span>
<span class="sd">    xu.edge_graph(G_test,plot_node_graph=True,plot_edge_graph=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">plot_node_graph</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node Graph before conversion&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="n">G_edge</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_edge_graph</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node Graph before conversion&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G_edge</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">G_edge</span></div>

<div class="viewcode-block" id="unique_vertices_edges_from_vertices_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.unique_vertices_edges_from_vertices_edges">[docs]</a><span class="k">def</span> <span class="nf">unique_vertices_edges_from_vertices_edges</span><span class="p">(</span>
    <span class="n">vertices</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_vertex_index</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">unique_verts</span><span class="p">,</span><span class="n">vert_first_index</span><span class="p">,</span><span class="n">verts_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">unique_edges</span> <span class="o">=</span> <span class="n">verts_index</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of vertices went from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_verts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_vertex_index</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unique_verts</span><span class="p">,</span><span class="n">unique_edges</span><span class="p">,</span><span class="n">vert_first_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unique_verts</span><span class="p">,</span><span class="n">unique_edges</span></div>

<div class="viewcode-block" id="graph_from_unique_vertices_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_from_unique_vertices_edges">[docs]</a><span class="k">def</span> <span class="nf">graph_from_unique_vertices_edges</span><span class="p">(</span>
    <span class="n">vertices</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>
    <span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">verts_unique</span> <span class="o">=</span> <span class="n">vertices</span>
    <span class="n">edges_unique</span> <span class="o">=</span> <span class="n">edges</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type</span><span class="p">)()</span>

    <span class="n">node_to_coord</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">verts_unique</span><span class="p">)}</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">verts_unique</span><span class="p">[</span><span class="n">edges_unique</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">verts_unique</span><span class="p">[</span><span class="n">edges_unique</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_to_coord</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edges_unique</span><span class="p">,</span><span class="n">weights</span><span class="p">]))</span>
    
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_to_coord</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="graph_from_non_unique_vertices_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_from_non_unique_vertices_edges">[docs]</a><span class="k">def</span> <span class="nf">graph_from_non_unique_vertices_edges</span><span class="p">(</span>
    <span class="n">vertices</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>
    <span class="n">graph_type</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
    
    <span class="n">verts_unique</span><span class="p">,</span><span class="n">edges_unique</span> <span class="o">=</span> <span class="n">unique_vertices_edges_from_vertices_edges</span><span class="p">(</span>
        <span class="n">vertices</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">graph_from_unique_vertices_edges</span><span class="p">(</span>
        <span class="n">vertices</span><span class="o">=</span><span class="n">verts_unique</span><span class="p">,</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">edges_unique</span><span class="p">,</span>
        <span class="n">graph_type</span> <span class="o">=</span> <span class="n">graph_type</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="shortest_path_graph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_graph">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_graph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">start</span><span class="p">,</span>
    <span class="n">end</span><span class="p">,</span>
    <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a path subgraph between </span>
<span class="sd">    two nodes </span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find shortest path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="shortest_path_from_most_upstream"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_from_most_upstream">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_from_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="n">most_up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">return_nodes</span><span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">most_up_node</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes_to_exclude</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">return_nodes</span></div>
    
<div class="viewcode-block" id="shortest_path_graph_from_most_upstream"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_graph_from_most_upstream">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_graph_from_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a path subgraph from</span>
<span class="sd">    the most upstream node to another node</span>

<span class="sd">    Psueodocode:</span>
<span class="sd">    1) Get the most upstream node</span>
<span class="sd">    2) Get the path subgraph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_from_most_upstream</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">node</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="undirected_sym_G_from_DiG"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.undirected_sym_G_from_DiG">[docs]</a><span class="k">def</span> <span class="nf">undirected_sym_G_from_DiG</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">keep_node_attributes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to construct a new graph with:</span>
<span class="sd">    adjusted adjacency matrix, node features</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Export the adjacency matrix with the node names</span>
<span class="sd">    2) Convert the adjacency matrix into a symmetric one</span>
<span class="sd">    3) Use new adjacency matrix and node names to create a new graph</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Export the adjacency matrix with the node names</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">return_nodelist</span> <span class="o">=</span> <span class="kc">True</span> 
    <span class="p">)</span>

    <span class="c1">#2) Convert the adjacency matrix into a symmetric one</span>
    <span class="n">A_undir</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    
    <span class="c1">#3) Use new adjacency matrix and node names to create a new graph</span>
    <span class="n">G_undir</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">G_from_adjacency_matrix</span><span class="p">(</span>
        <span class="n">A_undir</span><span class="p">,</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_node_attributes</span><span class="p">:</span>
        <span class="c1">#1b) Export the node attributes</span>
        <span class="n">node_df</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_from_df</span><span class="p">(</span>
            <span class="n">G_undir</span><span class="p">,</span>
            <span class="n">node_df</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After symmmetric conversion to undirected graph&quot;</span><span class="p">)</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">print_node_edges_counts</span><span class="p">(</span><span class="n">G_undir</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_undir</span></div>


<div class="viewcode-block" id="radius_threshold_graph_from_coordinates"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.radius_threshold_graph_from_coordinates">[docs]</a><span class="k">def</span> <span class="nf">radius_threshold_graph_from_coordinates</span><span class="p">(</span>
    <span class="n">coordinates</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Create a graph where the nodes of</span>
<span class="sd">    the graph come from the coordinates and the </span>
<span class="sd">    edges are between any 2 coordinates that</span>
<span class="sd">    are within a threshold distance of each other</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span>
        <span class="n">coordinates</span><span class="p">,</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">adj_matrix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">))</span><span class="o">*-</span><span class="mi">1</span>
    <span class="n">adj_matrix</span><span class="p">[</span><span class="n">adj_matrix</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">adj_matrix</span><span class="p">[</span><span class="n">adj_matrix</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">G_from_adjacency_matrix</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="filter_away_downstream_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.filter_away_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">filter_away_downstream_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to eliminate any nodes</span>
<span class="sd">    that are downstream of another in </span>
<span class="sd">    a group</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each node in the list:</span>
<span class="sd">    1) Compute the downstream nodes</span>
<span class="sd">    2) Do a set difference between the list to check</span>
<span class="sd">    and the downstream nodes to eliminate them</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    xu.filter_away_downstream_nodes(</span>
<span class="sd">        G,</span>
<span class="sd">        [&#39;L0_27&#39;, &#39;L1_17&#39;, &#39;L2_0&#39;, &#39;L3_1&#39;, &#39;L4_2&#39;, &#39;L5_9&#39;, &#39;L6_0&#39;,&quot;S0&quot;]</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_downstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">return_empty_list_if_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">])</span>
    <span class="n">nodes_no_downstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="n">all_downstream</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;List filtered from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes_no_downstream</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">nodes_no_downstream</span></div>

<div class="viewcode-block" id="values_on_relative_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.values_on_relative_nodes">[docs]</a><span class="k">def</span> <span class="nf">values_on_relative_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">include_self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">aggr_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">aggr_func</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">aggr_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">aggr_func</span><span class="p">)</span>

    <span class="n">node_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;all_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">_nodes&quot;</span><span class="p">)</span>

    <span class="c1">#1) Get all of the directional nodes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">node_func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">include_self</span><span class="o">=</span><span class="n">include_self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2"> Nodes = </span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Collect the attribute from all the nodes</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span><span class="n">default_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attributes = </span><span class="si">{</span><span class="n">attributes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes</span><span class="p">,</span><span class="n">nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">attributes</span></div>
    
<div class="viewcode-block" id="aggregate_values_on_relative_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.aggregate_values_on_relative_nodes">[docs]</a><span class="k">def</span> <span class="nf">aggregate_values_on_relative_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">include_self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">aggr_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To aggregate an attribute value</span>
<span class="sd">    downstream of a node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the directional nodes</span>
<span class="sd">    2) Collect the attribute from all the nodes</span>
<span class="sd">    3) Aggregate the attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="n">values_on_relative_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="p">,</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">default_value</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span>
        <span class="n">include_self</span> <span class="o">=</span> <span class="n">include_self</span><span class="p">,</span>
        <span class="n">aggr_func</span> <span class="o">=</span> <span class="n">aggr_func</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="c1">#3) Aggregate the attribute</span>
    <span class="n">aggr_value</span> <span class="o">=</span> <span class="n">aggr_func</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final value = </span><span class="si">{</span><span class="n">aggr_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">aggr_value</span></div>

<div class="viewcode-block" id="sum_downstream_attribute"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.sum_downstream_attribute">[docs]</a><span class="k">def</span> <span class="nf">sum_downstream_attribute</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">node</span><span class="p">,</span>
    <span class="n">attribute</span><span class="p">,</span>
    <span class="n">include_self</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">aggregate_values_on_relative_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">attribute</span><span class="p">,</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
        <span class="n">include_self</span><span class="o">=</span><span class="n">include_self</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="n_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span></div>

<div class="viewcode-block" id="n_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_edges">[docs]</a><span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span></div>

<div class="viewcode-block" id="n_edges_out"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_edges_out">[docs]</a><span class="k">def</span> <span class="nf">n_edges_out</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">graph_tools</span> <span class="kn">import</span> <span class="n">graph_statistics</span> <span class="k">as</span> <span class="n">gstat</span>
    <span class="n">degree_distr</span> <span class="o">=</span> <span class="n">gstat</span><span class="o">.</span><span class="n">degree_distribution</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">degree_distr</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_edges_in"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.n_edges_in">[docs]</a><span class="k">def</span> <span class="nf">n_edges_in</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">graph_tools</span> <span class="kn">import</span> <span class="n">graph_statistics</span> <span class="k">as</span> <span class="n">gstat</span>
    <span class="n">degree_distr</span> <span class="o">=</span> <span class="n">gstat</span><span class="o">.</span><span class="n">degree_distribution</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span><span class="n">degree_type</span><span class="o">=</span><span class="s2">&quot;in&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">degree_distr</span><span class="p">)</span></div>

<div class="viewcode-block" id="shortest_path_along_node_subset_old"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_along_node_subset_old">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_along_node_subset_old</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">start</span><span class="p">,</span>
    <span class="n">end</span><span class="p">,</span>
    <span class="n">node_subset</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the shortest path between</span>
<span class="sd">    two nodes but the intermediate nodes</span>
<span class="sd">    can only be from a certain subset of nodes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the nodes connected to start</span>
<span class="sd">    and end node (that are in subset)</span>
<span class="sd">    and make them group 1, group 2</span>
<span class="sd">    respectively</span>
<span class="sd">    2) Find the shortest distance between the </span>
<span class="sd">    subgraph of the subset</span>
<span class="sd">    3) Concatenate on the whole path</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">start_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">),</span>
        <span class="n">node_subset</span>
    <span class="p">),[</span><span class="n">start</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for start neighbors: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">end_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">return_single</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">node_subset</span>
    <span class="p">),[</span><span class="n">end</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for end neighbors: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#node_subset = np.setdiff1d(node_subset,[start,end])</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
        <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">node_subset</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="n">node_list_1</span><span class="o">=</span><span class="n">start_neighbors</span><span class="p">,</span>
        <span class="n">node_list_2</span> <span class="o">=</span> <span class="n">end_neighbors</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose_time</span><span class="p">,</span>
        <span class="n">return_node_pairs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">+</span> <span class="n">shortest_path</span>

    <span class="k">if</span> <span class="n">shortest_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path from </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">shortest_path</span></div>
        
    
<div class="viewcode-block" id="shortest_path_along_node_subset"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.shortest_path_along_node_subset">[docs]</a><span class="k">def</span> <span class="nf">shortest_path_along_node_subset</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">start</span><span class="p">,</span>
    <span class="n">end</span><span class="p">,</span>
    <span class="n">node_subset</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the path between two nodes</span>
<span class="sd">    but the path can only occur through a subset </span>
<span class="sd">    of the nodes</span>
<span class="sd">    </span>
<span class="sd">    -- Example: </span>
<span class="sd">    xu.shortest_path_along_node_subset(</span>
<span class="sd">        G,</span>
<span class="sd">        start = &#39;864691135939275265_0&#39;,</span>
<span class="sd">        end = &#39;864691135454090602_0&#39;,</span>
<span class="sd">        node_subset = conu.excitatory_nodes(G_auto),</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        verbose_time = True,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">global_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">curr_G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_subset</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total time for subgraph = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total time for shortest_path = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path from </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total time for shortest path along nodes = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">shortest_path</span></div>

<div class="viewcode-block" id="largest_connected_component"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.largest_connected_component">[docs]</a><span class="k">def</span> <span class="nf">largest_connected_component</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="n">largest_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Largest connected component size = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">[</span><span class="n">largest_idx</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">[</span><span class="n">largest_idx</span><span class="p">]))</span></div>

<div class="viewcode-block" id="from_pandas_edgelist"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.from_pandas_edgelist">[docs]</a><span class="k">def</span> <span class="nf">from_pandas_edgelist</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">source</span><span class="o">=</span><span class="s1">&#39;source&#39;</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">,</span>
    <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">create_using</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#nx.Graph,nx.MultiDiGraph</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">edge_attr</span><span class="o">=</span><span class="n">edge_attr</span><span class="p">,</span>
        <span class="n">create_using</span><span class="o">=</span><span class="n">create_using</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for Graph creating = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="graph_type_from_G"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.graph_type_from_G">[docs]</a><span class="k">def</span> <span class="nf">graph_type_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">gt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Graph&quot;</span><span class="p">,</span><span class="s2">&quot;DiGraph&quot;</span><span class="p">,</span><span class="s2">&quot;MultiGraph&quot;</span><span class="p">,</span><span class="s2">&quot;MultiDiGraph&quot;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;type(G) == getattr(nx,&#39;</span><span class="si">{</span><span class="n">gt</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">gt</span>
    <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="empty_graph_type_from_G"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.empty_graph_type_from_G">[docs]</a><span class="k">def</span> <span class="nf">empty_graph_type_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">graph_type_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">))()</span></div>


<div class="viewcode-block" id="edge_subgraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.edge_subgraph">[docs]</a><span class="k">def</span> <span class="nf">edge_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">edges</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes">[docs]</a><span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span></div>

<div class="viewcode-block" id="random_edges_from_existing_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.random_edges_from_existing_edges">[docs]</a><span class="k">def</span> <span class="nf">random_edges_from_existing_edges</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">samples_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">random_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">random_idx</span><span class="p">(</span>
        <span class="n">n_samples</span><span class="o">=</span><span class="n">n_samples</span><span class="p">,</span>
        <span class="n">array_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span>
        <span class="n">samples_perc</span> <span class="o">=</span> <span class="n">samples_perc</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">random_idx</span><span class="p">,:]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for random edges from existing edges: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">new_edges</span></div>

<div class="viewcode-block" id="random_edges_from_existing_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.random_edges_from_existing_nodes">[docs]</a><span class="k">def</span> <span class="nf">random_edges_from_existing_nodes</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">n_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">buffer_multiplier</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">no_self_loops</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">unique_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">error_if_not_enough_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a random </span>
<span class="sd">    list of edges by sampling the</span>
<span class="sd">    nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">n_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span><span class="o">*</span><span class="n">samples_perc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">curr_samples</span> <span class="o">=</span> <span class="n">n_samples</span><span class="o">*</span><span class="n">buffer_multiplier</span>

    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed_1</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="n">seed_2</span> <span class="o">=</span> <span class="n">seed</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seed_1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">seed_2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">nodes_idx_1</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">random_idx</span><span class="p">(</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">curr_samples</span><span class="p">,</span>
        <span class="n">array_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed_1</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">nodes_idx_2</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">random_idx</span><span class="p">(</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">curr_samples</span><span class="p">,</span>
        <span class="n">array_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed_2</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">no_self_loops</span><span class="p">:</span>
        <span class="n">good_map</span>  <span class="o">=</span> <span class="n">nodes_idx_1</span> <span class="o">!=</span> <span class="n">nodes_idx_2</span>
        <span class="n">nodes_idx_1</span> <span class="o">=</span> <span class="n">nodes_idx_1</span><span class="p">[</span><span class="n">good_map</span><span class="p">]</span>
        <span class="n">nodes_idx_2</span> <span class="o">=</span> <span class="n">nodes_idx_2</span><span class="p">[</span><span class="n">good_map</span><span class="p">]</span>
    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">nodes_idx_1</span><span class="p">,</span><span class="n">nodes_idx_2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">unique_edges</span><span class="p">:</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_samples</span> <span class="ow">and</span> <span class="n">error_if_not_enough_edges</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">new_edges</span><span class="p">][:</span><span class="n">n_samples</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for random edges from existing nodes: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="remove_self_loops"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_self_loops">[docs]</a><span class="k">def</span> <span class="nf">remove_self_loops</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">selfloop_edges</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="configuration_model"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.configuration_model">[docs]</a><span class="k">def</span> <span class="nf">configuration_model</span><span class="p">(</span>
    <span class="n">G</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">degree_sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">create_using</span> <span class="o">=</span> <span class="s2">&quot;Graph&quot;</span><span class="p">,</span>
    <span class="n">self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">create_using</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">create_using</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">create_using</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">degree_sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">degree_sequence</span> <span class="o">=</span> <span class="n">degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">G_new</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">configuration_model</span><span class="p">(</span><span class="n">degree_sequence</span><span class="p">,</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span><span class="n">create_using</span> <span class="o">=</span> <span class="n">create_using</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">self_loops</span><span class="p">:</span>
        <span class="n">G_new</span> <span class="o">=</span> <span class="n">remove_self_loops</span><span class="p">(</span><span class="n">G_new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_new</span></div>

<div class="viewcode-block" id="directed_configuration_model"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.directed_configuration_model">[docs]</a><span class="k">def</span> <span class="nf">directed_configuration_model</span><span class="p">(</span>
    <span class="n">G</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">in_degree_sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out_degree_sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">create_using</span> <span class="o">=</span> <span class="s2">&quot;MultiDiGraph&quot;</span><span class="p">,</span>
    <span class="n">self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">create_using</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">create_using</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">create_using</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">out_degree_sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_degree_sequence</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">out_degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_degree_sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">in_degree_sequence</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">in_degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="n">G_new</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">directed_configuration_model</span><span class="p">(</span>
        <span class="n">in_degree_sequence</span><span class="o">=</span><span class="n">in_degree_sequence</span><span class="p">,</span>
        <span class="n">out_degree_sequence</span><span class="o">=</span><span class="n">out_degree_sequence</span><span class="p">,</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span>
        <span class="n">create_using</span> <span class="o">=</span> <span class="n">create_using</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">self_loops</span><span class="p">:</span>
        <span class="n">G_new</span> <span class="o">=</span> <span class="n">remove_self_loops</span><span class="p">(</span><span class="n">G_new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_new</span></div>

<div class="viewcode-block" id="random_edges_subgraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.random_edges_subgraph">[docs]</a><span class="k">def</span> <span class="nf">random_edges_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">edges_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">samples_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_edge_generation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_degree_sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out_degree_sequence</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    
    <span class="k">if</span> <span class="n">edges_func</span> <span class="o">==</span> <span class="s2">&quot;degree_config_model&quot;</span><span class="p">:</span>
        <span class="n">G_new</span> <span class="o">=</span> <span class="n">directed_configuration_model</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">in_degree_sequence</span> <span class="o">=</span> <span class="n">in_degree_sequence</span><span class="p">,</span>
            <span class="n">out_degree_sequence</span> <span class="o">=</span> <span class="n">out_degree_sequence</span><span class="p">,</span>
            <span class="n">self_loops</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">create_using</span> <span class="o">=</span> <span class="s2">&quot;DiGraph&quot;</span><span class="p">,</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edges_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges_func</span> <span class="o">=</span> <span class="n">random_edges_from_existing_edges</span>
        <span class="k">elif</span> <span class="n">edges_func</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span><span class="p">:</span>
            <span class="n">edges_func</span> <span class="o">=</span> <span class="n">random_edges_from_existing_edges</span>
        <span class="k">elif</span> <span class="n">edges_func</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
            <span class="n">edges_func</span> <span class="o">=</span> <span class="n">random_edges_from_existing_nodes</span>


        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">edges_func</span><span class="p">(</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">,</span>
            <span class="n">random_idx</span> <span class="o">=</span> <span class="n">random_idx</span><span class="p">,</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">n_samples</span><span class="p">,</span>
            <span class="n">samples_perc</span> <span class="o">=</span> <span class="n">samples_perc</span><span class="p">,</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose_edge_generation</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">edges_func</span> <span class="o">==</span> <span class="n">random_edges_from_existing_edges</span><span class="p">:</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">])</span>
            <span class="n">G_new</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">new_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_new</span> <span class="o">=</span> <span class="n">empty_graph_type_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="n">G_new</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for random subgraph: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">print_node_edges_counts</span><span class="p">(</span><span class="n">G_new</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G_new</span></div>

<div class="viewcode-block" id="degree_sequence"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.degree_sequence">[docs]</a><span class="k">def</span> <span class="nf">degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">()])</span></div>
    
<div class="viewcode-block" id="out_degree_sequence"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.out_degree_sequence">[docs]</a><span class="k">def</span> <span class="nf">out_degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()])</span></div>
    
<div class="viewcode-block" id="in_degree_sequence"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.in_degree_sequence">[docs]</a><span class="k">def</span> <span class="nf">in_degree_sequence</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">()])</span></div>
    
<div class="viewcode-block" id="degree_sequence_from_adj"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.degree_sequence_from_adj">[docs]</a><span class="k">def</span> <span class="nf">degree_sequence_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="out_degree_sequence_from_adj"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.out_degree_sequence_from_adj">[docs]</a><span class="k">def</span> <span class="nf">out_degree_sequence_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="in_degree_sequence_from_adj"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.in_degree_sequence_from_adj">[docs]</a><span class="k">def</span> <span class="nf">in_degree_sequence_from_adj</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_pairs_shortest_path_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_pairs_shortest_path_matrix">[docs]</a><span class="k">def</span> <span class="nf">all_pairs_shortest_path_matrix</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">self_path_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dist_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dist_func_weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="n">undirected</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find the shortest path between all combinations of nodes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">self_path_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">self_path_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shortest_path_matrix</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">empty_n_by_m_default_matrix</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
    
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_path_value</span>
                <span class="k">if</span> <span class="n">dist_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">weight</span> <span class="o">=</span> <span class="n">dist_func_weight</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">j</span> <span class="ow">and</span> <span class="n">undirected</span><span class="p">:</span>
                <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">suppress_errors</span><span class="p">:</span>
                        <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_path_value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dist_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest_path_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span><span class="n">weight</span> <span class="o">=</span> <span class="n">dist_func_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for all_pairs_shortest_path_matrix= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">shortest_path_matrix</span></div>

<span class="c1">#from networkx.classes.function import path_weight as pw</span>

<div class="viewcode-block" id="path_weight"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.path_weight">[docs]</a><span class="k">def</span> <span class="nf">path_weight</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">path</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="n">empty_path_value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">empty_path_value</span>
    <span class="k">return</span> <span class="n">pw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">)</span></div>
<span class="n">path_length_from_path</span> <span class="o">=</span> <span class="n">path_weight</span>

<div class="viewcode-block" id="all_pairs_shortest_path_length_matrix"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.all_pairs_shortest_path_length_matrix">[docs]</a><span class="k">def</span> <span class="nf">all_pairs_shortest_path_length_matrix</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">dist_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">self_path_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">undirected</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">dist_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist_func</span> <span class="o">=</span> <span class="n">path_weight</span>
        
    <span class="n">path_matrix</span> <span class="o">=</span> <span class="n">all_pairs_shortest_path_matrix</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="n">self_path_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dist_func</span> <span class="o">=</span> <span class="n">dist_func</span><span class="p">,</span>
        <span class="n">dist_func_weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">,</span>
        <span class="n">undirected</span> <span class="o">=</span> <span class="n">undirected</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">suppress_errors</span><span class="o">=</span><span class="n">suppress_errors</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="n">path_matrix</span><span class="p">[</span><span class="n">path_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_path_value</span>
    <span class="k">return</span> <span class="n">path_matrix</span></div>
    
    
<div class="viewcode-block" id="largest_component_subgraph"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.largest_component_subgraph">[docs]</a><span class="k">def</span> <span class="nf">largest_component_subgraph</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the percentage of neurons not in the</span>
<span class="sd">    largest component</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) compute the connected components</span>
<span class="sd">    2) Find the largest idx</span>
<span class="sd">    3) Divide the sum of all those not the largest idx by the</span>
<span class="sd">    largest idx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conn_comps</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">conn_comps_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comps</span><span class="p">])</span>
    <span class="n">giant_component_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">conn_comps_len</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;giant_component_size = </span><span class="si">{</span><span class="n">conn_comps_len</span><span class="p">[</span><span class="n">giant_component_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">conn_comps</span><span class="p">[</span><span class="n">giant_component_idx</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="largest_component_n_nodes"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.largest_component_n_nodes">[docs]</a><span class="k">def</span> <span class="nf">largest_component_n_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n_nodes</span><span class="p">(</span><span class="n">largest_component_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">))</span></div>

<div class="viewcode-block" id="largest_component_node_perc"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.largest_component_node_perc">[docs]</a><span class="k">def</span> <span class="nf">largest_component_node_perc</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">largest_component_n_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">/</span><span class="n">n_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>

<div class="viewcode-block" id="nodes_with_no_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.nodes_with_no_edges">[docs]</a><span class="k">def</span> <span class="nf">nodes_with_no_edges</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">isolates</span><span class="p">(</span><span class="n">G</span><span class="p">))</span></div>

<div class="viewcode-block" id="remove_nodes_with_no_edges"><a class="viewcode-back" href="../../python_tools.html#python_tools.networkx_utils.remove_nodes_with_no_edges">[docs]</a><span class="k">def</span> <span class="nf">remove_nodes_with_no_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes_with_no_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>



<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">regex_utils</span> <span class="k">as</span> <span class="n">ru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">string_utils</span> <span class="k">as</span> <span class="n">stru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tqdm_utils</span> <span class="k">as</span> <span class="n">tqu</span>
<span class="kn">from</span> <span class="nn">.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>